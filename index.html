<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Crown Arena v1.1</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            color: white;
            font-family: 'Segoe UI', monospace;
            touch-action: none;
            user-select: none;
        }

        canvas {
            display: block;
        }

        /* --- UI Layers --- */
        .layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.9);
            z-index: 20;
            transition: opacity 0.3s;
            pointer-events: auto;
        }

        .panel {
            background: #2a2a2a;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid #444;
            width: 320px;
            max-width: 90%;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }

        h1 { margin: 0 0 20px 0; color: #ffd700; font-size: 28px; text-shadow: 0 0 10px #ff8c00; }
        h2 { margin: 0 0 15px 0; font-size: 36px; font-weight: bold; }

        input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 6px;
            font-size: 16px;
            text-align: center;
        }

        button {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            color: white;
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.98); }

        .btn-host { background: #0078d7; }
        .btn-join { background: #107c10; }
        .btn-restart { background: #e6c200; color: black; }
        .btn-close { background: #d32f2f; }

        .win { color: #00ff00; }
        .lose { color: #ff0000; }
        .draw { color: #aaaaaa; }

        /* --- HUD --- */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* Timer */
        #timer-container {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 5px #000;
        }
        
        /* HP Bars */
        .player-info {
            position: absolute;
            top: 10px;
            font-size: 14px;
            text-shadow: 1px 1px 2px black;
        }
        .p1-info { left: 10px; }
        .p2-info { right: 10px; text-align: right; }

        .hp-bar-bg {
            width: 120px;
            height: 10px;
            background: #333;
            border: 1px solid #777;
            margin-top: 5px;
        }
        .hp-fill {
            height: 100%;
            background: #0f0;
            width: 100%;
            transition: width 0.2s, background-color 0.2s;
        }

        /* --- ULT UI --- */
        #ult-container {
            position: absolute;
            top: 60px;
            right: 10px;
            width: 60px;
            text-align: center;
            pointer-events: auto; /* ボタン押せるように */
        }
        .ult-gauge-bg {
            width: 100%;
            height: 8px;
            background: #333;
            border: 1px solid #aaa;
            margin-bottom: 5px;
        }
        .ult-fill {
            height: 100%;
            background: #d000ff;
            width: 0%;
            transition: width 0.2s;
        }
        #btn-ult {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #444;
            color: #888;
            font-weight: bold;
            font-size: 14px;
            border: 2px solid #666;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: default;
            transition: all 0.2s;
        }
        #btn-ult.ready {
            background: #9c27b0;
            color: white;
            border-color: #fff;
            box-shadow: 0 0 15px #d000ff;
            cursor: pointer;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        #room-id-display {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.5);
            font-size: 12px;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="layer-menu" class="layer">
        <div class="panel">
            <h1>Crown Arena v1.1</h1>
            <button class="btn-host" id="btn-create">Create Room (Host)</button>
            <div style="margin: 10px 0; color:#666;">- OR -</div>
            <input type="number" id="input-room" placeholder="4-Digit Room ID">
            <button class="btn-join" id="btn-join">Join Room</button>
            <div id="status-msg" style="margin-top:10px; color:#aaa; font-size:12px;">Ready</div>
        </div>
    </div>

    <div id="layer-wait" class="layer hidden">
        <div class="panel">
            <h1>Waiting for Player...</h1>
            <div>Room ID</div>
            <div id="display-room-code" style="font-size:32px; color:#ffeb3b; font-weight:bold; margin:10px 0;">----</div>
            <div style="font-size: 12px; color: #aaa;">Share this ID</div>
        </div>
    </div>

    <div id="layer-result" class="layer hidden">
        <div class="panel">
            <h2 id="result-title">RESULT</h2>
            <div id="result-msg" style="margin-bottom:20px;"></div>
            
            <div id="host-controls" class="hidden">
                <button class="btn-restart" id="btn-restart">Play Again</button>
                <button class="btn-close" id="btn-close">Disband Room</button>
            </div>
            
            <div id="guest-controls" class="hidden">
                <div style="color:#aaa; margin-bottom:10px;">Waiting for Host...</div>
                <button class="btn-close" id="btn-leave">Leave Room</button>
            </div>
        </div>
    </div>

    <div id="hud" class="hidden">
        <div id="timer-container">60</div>

        <div class="player-info p1-info">
            P1 (Blue)
            <div class="hp-bar-bg"><div id="bar-hp-p1" class="hp-fill"></div></div>
        </div>
        
        <div class="player-info p2-info">
            P2 (Green)
            <div class="hp-bar-bg"><div id="bar-hp-p2" class="hp-fill"></div></div>
        </div>

        <div id="ult-container">
            <div class="ult-gauge-bg"><div id="bar-ult" class="ult-fill"></div></div>
            <div id="btn-ult">ULT</div>
        </div>

        <div id="room-id-display">Room: ----</div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script type="module">
    // ---------------------------------------------------------
    // 1. Firebase Config & Imports
    // ---------------------------------------------------------
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { 
        getFirestore, doc, setDoc, updateDoc, onSnapshot, getDoc, deleteDoc, increment 
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    const firebaseConfig = {
        apiKey: "AIzaSyA8B-JtwDskK3omhjUCbjERHBZ6UDdm854",
        authDomain: "crownarena-1a321.firebaseapp.com",
        projectId: "crownarena-1a321",
        storageBucket: "crownarena-1a321.firebasestorage.app",
        messagingSenderId: "103440875843",
        appId: "1:103440875843:web:d34b314c4df7e0d491aff6",
        measurementId: "G-N9KDL9B9Y5"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // ---------------------------------------------------------
    // 2. Constants & Globals
    // ---------------------------------------------------------
    const CANVAS = document.getElementById('gameCanvas');
    const CTX = CANVAS.getContext('2d');
    
    // Game Config
    const PLAYER_RADIUS = 20;
    const BULLET_RADIUS = 6;
    const ULT_RADIUS = 20;
    const MOVE_SPEED = 5;
    const BULLET_SPEED = 12;
    const FIRE_RATE = 250; 
    const SYNC_INTERVAL = 50; 
    
    const GAME_DURATION = 60; 
    const ULT_MAX = 100;
    const ULT_CHARGE_PASSIVE = 5; // 毎秒
    const ULT_CHARGE_HIT = 10;    // 被弾時

    // ---------------------------------------------------------
    // 3. Game Logic Class
    // ---------------------------------------------------------
    class Game {
        constructor() {
            this.roomId = null;
            this.isHost = false; 
            this.myId = null; // 'p1' or 'p2'
            
            // ゲーム状態
            this.state = {
                players: {
                    p1: { x: 100, y: 100, hp: 100, active: false, ult: 0, slowUntil: 0 },
                    p2: { x: 300, y: 100, hp: 100, active: false, ult: 0, slowUntil: 0 }
                },
                status: "waiting", // waiting, playing, finished
                remainingTime: GAME_DURATION,
                startTime: null,
                bulletSeq: 0,
                ultSeq: 0
            };

            this.localBullets = []; 
            this.particles = []; // 発射エフェクト用

            // Input
            this.input = {
                move: { active: false, x: 0, y: 0, id: null, baseX: 0, baseY: 0 },
                aim:  { active: false, x: 0, y: 0, id: null, baseX: 0, baseY: 0, angle: 0 },
                fireTrigger: false // フレームごとの発射フラグ
            };
            
            // Timers
            this.lastSyncTime = 0;
            this.lastTimeTick = 0;
            this.lastFrameTime = Date.now();
            this.lastFireTime = 0;
            this.unsubscribe = null;
            this.isRoomReady = false;

            this.resize();
            window.addEventListener('resize', () => this.resize());
            this.setupInputs();
            
            // UI References
            this.layers = {
                menu: document.getElementById('layer-menu'),
                wait: document.getElementById('layer-wait'),
                result: document.getElementById('layer-result')
            };
            this.hud = document.getElementById('hud');
            
            this.bindButtons();

            // Loop
            requestAnimationFrame((t) => this.loop(t));
        }

        resize() {
            CANVAS.width = window.innerWidth;
            CANVAS.height = window.innerHeight;
            // 固定スティック位置は使わず、タッチ位置基準のダイナミック方式にするためリサイズ処理は最小限
        }

        // --- Network Actions ---

        async createRoom() {
            this.roomId = Math.floor(1000 + Math.random() * 9000).toString();
            this.isHost = true;
            this.myId = 'p1';
            
            // 初期化
            this.state.players.p1.active = true;
            this.state.players.p1.x = 100;
            this.state.players.p1.hp = 100;
            this.state.players.p1.ult = 0;
            this.state.players.p1.slowUntil = 0;

            const initialData = {
                players: {
                    p1: this.state.players.p1,
                    p2: { x: 300, y: 100, hp: 100, active: false, ult: 0, slowUntil: 0 }
                },
                status: "waiting",
                startTime: null,
                winner: null,
                bulletSeq: 0,
                ultSeq: 0,
                lastShooter: null,
                lastAngle: 0 // 追加: 弾の角度
            };

            try {
                await setDoc(doc(db, "rooms", this.roomId), initialData);
                this.isRoomReady = true;
                this.switchLayer('wait');
                document.getElementById('display-room-code').innerText = this.roomId;
                document.getElementById('room-id-display').innerText = "Room: " + this.roomId;
                this.subscribeToRoom();
            } catch (e) {
                console.error("Create Error:", e);
                alert("Error creating room.");
            }
        }

        async joinRoom(id) {
            const docRef = doc(db, "rooms", id);
            try {
                const snap = await getDoc(docRef);
                if (!snap.exists()) { 
                    alert("Room not found!"); 
                    return; 
                }
                const data = snap.data();
                if (data.status === "closed") {
                    alert("Room is closed.");
                    return;
                }

                this.roomId = id;
                this.isHost = false;
                this.myId = 'p2';

                this.state.players.p2.active = true;
                this.state.players.p2.x = CANVAS.width - 100;
                this.state.players.p2.hp = 100;
                this.state.players.p2.ult = 0;

                await updateDoc(docRef, {
                    "players.p2.active": true,
                    "players.p2.x": this.state.players.p2.x
                });

                document.getElementById('room-id-display').innerText = "Room: " + this.roomId;
                this.isRoomReady = true;
                this.subscribeToRoom();

            } catch (e) {
                console.error("Join Error:", e);
                alert("Error joining room.");
            }
        }

        subscribeToRoom() {
            if (this.unsubscribe) this.unsubscribe();
            
            this.unsubscribe = onSnapshot(doc(db, "rooms", this.roomId), (docSnap) => {
                if (!docSnap.exists()) {
                    console.warn("Snapshot: Document does not exist (ignoring temporary glitch)");
                    return;
                }
                const data = docSnap.data();
                
                if (data.status === "closed") {
                    alert("Room was closed by host.");
                    location.reload();
                    return;
                }

                // ゲーム開始処理 (Host Only)
                if (this.isHost && this.state.status === "waiting" && data.players.p2 && data.players.p2.active) {
                    this.startGameAsHost();
                }

                // ステータス同期
                if (data.status === "playing") {
                    this.switchLayer(null); 
                    this.state.status = "playing";
                    this.hud.classList.remove('hidden');
                } else if (data.status === "finished") {
                    this.state.status = "finished";
                    this.hud.classList.add('hidden');
                    this.showResult(data.winner);
                }

                // タイマー同期
                if (data.startTime) {
                    this.state.startTime = data.startTime;
                }

                // 弾丸イベント (角度情報付き)
                if (data.bulletSeq > this.state.bulletSeq) {
                    if (data.lastShooter !== this.myId) {
                        this.spawnBulletFromSync(data.lastShooter, false, data.lastAngle);
                    }
                    this.state.bulletSeq = data.bulletSeq;
                }
                if (data.ultSeq > this.state.ultSeq) {
                    if (data.lastShooter !== this.myId) {
                        this.spawnBulletFromSync(data.lastShooter, true, data.lastAngle);
                    }
                    this.state.ultSeq = data.ultSeq;
                }

                // プレイヤー情報同期
                if (this.isHost) {
                    if (data.players.p2) {
                        const p2 = this.state.players.p2;
                        p2.x = data.players.p2.x;
                        p2.y = data.players.p2.y;
                        p2.active = data.players.p2.active;
                    }
                } else {
                    if (data.players.p1) {
                        Object.assign(this.state.players.p1, data.players.p1);
                    }
                    if (data.players.p2) {
                        const p2 = this.state.players.p2;
                        p2.hp = data.players.p2.hp;
                        p2.ult = data.players.p2.ult;
                        p2.slowUntil = data.players.p2.slowUntil;
                        p2.active = data.players.p2.active;
                    }
                }
                
                this.updateUI();
            });
        }

        async startGameAsHost() {
            const now = Date.now();
            this.state.startTime = now;
            this.state.status = "playing";
            
            try {
                await updateDoc(doc(db, "rooms", this.roomId), {
                    startTime: now,
                    status: "playing"
                });
            } catch(e) {
                console.error("Start Game Error:", e);
            }
        }

        async syncToFirestore() {
            if (!this.roomId || this.state.status === "finished") return;
            const ref = doc(db, "rooms", this.roomId);
            const me = this.state.players[this.myId];

            try {
                if (this.isHost) {
                    await updateDoc(ref, {
                        "remainingTime": Math.ceil(this.state.remainingTime),
                        "players.p1.x": me.x,
                        "players.p1.y": me.y,
                        "players.p1.hp": this.state.players.p1.hp,
                        "players.p1.ult": Math.floor(this.state.players.p1.ult),
                        "players.p1.slowUntil": this.state.players.p1.slowUntil,

                        "players.p2.hp": this.state.players.p2.hp,
                        "players.p2.ult": Math.floor(this.state.players.p2.ult),
                        "players.p2.slowUntil": this.state.players.p2.slowUntil
                    });
                } else {
                    await updateDoc(ref, {
                        "players.p2.x": me.x,
                        "players.p2.y": me.y
                    });
                }
            } catch (e) { /* ignore lag */ }
        }

        // --- Bullet Logic ---

        // 攻撃スティックリリース時に呼ばれる
        triggerFire(angle) {
            const now = Date.now();
            // クールダウン
            if (now - this.lastFireTime < FIRE_RATE) return;
            this.lastFireTime = now;

            // ローカル生成
            this.spawnBulletLocal(this.myId, false, angle);
            
            // Firestore送信
            this.sendFireEvent(false, angle);
        }

        triggerUlt() {
            const me = this.state.players[this.myId];
            if (me.ult < ULT_MAX) return;

            me.ult = 0;
            // エイム中の角度があればそれを使う、なければデフォルト(P1右/P2左)
            let angle = this.input.aim.active ? this.input.aim.angle : (this.myId === 'p1' ? 0 : Math.PI);
            
            this.spawnBulletLocal(this.myId, true, angle);
            this.sendFireEvent(true, angle);
        }

        async sendFireEvent(isUlt, angle) {
            const ref = doc(db, "rooms", this.roomId);
            try {
                if (isUlt) {
                    await updateDoc(ref, { 
                        ultSeq: increment(1), 
                        lastShooter: this.myId,
                        lastAngle: angle
                    });
                } else {
                    await updateDoc(ref, { 
                        bulletSeq: increment(1), 
                        lastShooter: this.myId,
                        lastAngle: angle
                    });
                }
            } catch(e) {}
        }

        spawnBulletFromSync(shooterId, isUlt, angle) {
            this.spawnBulletLocal(shooterId, isUlt, angle);
        }

        spawnBulletLocal(ownerId, isUlt, angle) {
            const p = this.state.players[ownerId];
            if (!p || !p.active) return;

            this.localBullets.push({
                x: p.x, 
                y: p.y, 
                vx: Math.cos(angle) * BULLET_SPEED, 
                vy: Math.sin(angle) * BULLET_SPEED, 
                owner: ownerId, 
                isUlt: isUlt, 
                r: isUlt ? ULT_RADIUS : BULLET_RADIUS
            });

            // 発射エフェクト
            this.particles.push({
                x: p.x + Math.cos(angle) * 30,
                y: p.y + Math.sin(angle) * 30,
                life: 10,
                color: isUlt ? '#d000ff' : '#ffff00'
            });
        }

        // --- Loop ---

        update(dt) {
            const now = Date.now();
            const deltaTimeSec = (now - this.lastFrameTime) / 1000;
            this.lastFrameTime = now;

            // Timer
            if (this.state.status === "playing" && this.state.startTime) {
                const elapsed = (now - this.state.startTime) / 1000;
                this.state.remainingTime = Math.max(0, GAME_DURATION - elapsed);
                
                if (this.isHost && this.state.remainingTime <= 0) {
                    this.checkTimeOver();
                }
            }

            if (this.state.status === "playing") {
                // Host Logic
                if (this.isHost) {
                    ['p1', 'p2'].forEach(pid => {
                        const p = this.state.players[pid];
                        if (p.active && p.ult < ULT_MAX) {
                            p.ult += ULT_CHARGE_PASSIVE * deltaTimeSec;
                            if (p.ult > ULT_MAX) p.ult = ULT_MAX;
                        }
                    });
                }

                // Movement
                const me = this.state.players[this.myId];
                if (me) {
                    let speed = MOVE_SPEED;
                    if (now < me.slowUntil) speed *= 0.5;

                    // 移動スティックの入力反映
                    if (this.input.move.active) {
                        const mx = Math.cos(this.input.move.angle);
                        const my = Math.sin(this.input.move.angle);
                        // スティックの倒し具合(dist)も考慮できるが今回は正規化方向へ等速移動
                        me.x += mx * speed;
                        me.y += my * speed;
                    }

                    me.x = Math.max(20, Math.min(CANVAS.width - 20, me.x));
                    me.y = Math.max(20, Math.min(CANVAS.height - 20, me.y));
                }
            }

            this.updateBullets();
            this.updateParticles();

            if (now - this.lastSyncTime > SYNC_INTERVAL) {
                this.syncToFirestore();
                this.lastSyncTime = now;
            }
        }

        updateBullets() {
            // 移動
            this.localBullets.forEach(b => {
                b.x += b.vx;
                b.y += b.vy;
            });

            // 削除
            this.localBullets = this.localBullets.filter(b => 
                b.x > 0 && b.x < CANVAS.width && b.y > 0 && b.y < CANVAS.height
            );

            // 当たり判定
            this.localBullets = this.localBullets.filter(b => {
                let hit = false;
                const targetId = b.owner === 'p1' ? 'p2' : 'p1';
                const target = this.state.players[targetId];

                if (target.active && target.hp > 0) {
                    const dx = b.x - target.x;
                    const dy = b.y - target.y;
                    
                    if (Math.hypot(dx, dy) < PLAYER_RADIUS + b.r) {
                        hit = true; 
                        
                        // HP計算 (Hostのみ)
                        if (this.isHost) {
                            const dmg = b.isUlt ? 20 : 10;
                            target.hp -= dmg;
                            
                            // ULTチャージ (被弾)
                            target.ult = Math.min(ULT_MAX, target.ult + ULT_CHARGE_HIT);

                            if (b.isUlt) target.slowUntil = Date.now() + 3000;

                            if (target.hp <= 0) {
                                target.hp = 0;
                                this.endGame(b.owner);
                            }
                        }
                    }
                }
                return !hit; 
            });
        }

        updateParticles() {
            this.localBullets.forEach(b => {
                // 弾の軌跡用パーティクル（簡易）
                if (Math.random() < 0.3) {
                    this.particles.push({
                        x: b.x, y: b.y, life: 5, color: b.isUlt ? '#d000ff' : '#ffff00', size: 2
                    });
                }
            });

            this.particles.forEach(p => p.life--);
            this.particles = this.particles.filter(p => p.life > 0);
        }

        checkTimeOver() {
            const p1 = this.state.players.p1.hp;
            const p2 = this.state.players.p2.hp;
            let winner = null;
            if (p1 > p2) winner = 'p1';
            else if (p2 > p1) winner = 'p2';
            else winner = 'draw';
            this.endGame(winner);
        }

        async endGame(winnerId) {
            if (!this.isHost || this.state.status === "finished") return;
            this.state.status = "finished";
            
            await updateDoc(doc(db, "rooms", this.roomId), {
                "status": "finished",
                "winner": winnerId,
                "remainingTime": 0,
                "players.p1.hp": this.state.players.p1.hp,
                "players.p2.hp": this.state.players.p2.hp
            });
        }

        // --- UI ---

        switchLayer(name) {
            for (let key in this.layers) {
                if (key === name) this.layers[key].classList.remove('hidden');
                else this.layers[key].classList.add('hidden');
            }
        }

        updateUI() {
            const timerEl = document.getElementById('timer-container');
            if (timerEl) {
                timerEl.innerText = Math.max(0, Math.ceil(this.state.remainingTime));
            }

            const p1 = this.state.players.p1;
            const p2 = this.state.players.p2;
            
            const barP1 = document.getElementById('bar-hp-p1');
            if (barP1) {
                barP1.style.width = Math.max(0, p1.hp) + "%";
                barP1.style.backgroundColor = p1.hp > 30 ? '#0f0' : '#f00';
            }

            const barP2 = document.getElementById('bar-hp-p2');
            if (barP2) {
                barP2.style.width = Math.max(0, p2.hp) + "%";
                barP2.style.backgroundColor = p2.hp > 30 ? '#0f0' : '#f00';
            }

            const myUlt = this.state.players[this.myId]?.ult || 0;
            const barUlt = document.getElementById('bar-ult');
            if (barUlt) {
                barUlt.style.width = Math.min(100, Math.max(0, myUlt)) + "%";
            }
            
            const btnUlt = document.getElementById('btn-ult');
            if (btnUlt) {
                if (myUlt >= ULT_MAX) btnUlt.classList.add('ready');
                else btnUlt.classList.remove('ready');
            }
        }

        showResult(winnerId) {
            this.switchLayer('result');
            const title = document.getElementById('result-title');
            const msg = document.getElementById('result-msg');
            
            if (winnerId === 'draw') {
                title.innerText = "DRAW";
                title.className = "draw";
                msg.innerText = "Time Over";
            } else {
                const amIWinner = (winnerId === this.myId);
                if (amIWinner) {
                    title.innerText = "YOU WIN!";
                    title.className = "win";
                    msg.innerText = "Congratulations!";
                } else {
                    title.innerText = "YOU LOSE";
                    title.className = "lose";
                    msg.innerText = "Try again next time.";
                }
            }

            if (this.isHost) {
                document.getElementById('host-controls').classList.remove('hidden');
                document.getElementById('guest-controls').classList.add('hidden');
            } else {
                document.getElementById('host-controls').classList.add('hidden');
                document.getElementById('guest-controls').classList.remove('hidden');
            }
        }

        async restartGame() {
            if (!this.isHost) return;
            
            const now = Date.now();
            this.state.players.p1.hp = 100;
            this.state.players.p1.x = 100;
            this.state.players.p1.ult = 0;
            this.state.players.p1.slowUntil = 0;
            this.state.players.p2.hp = 100;
            this.state.players.p2.x = CANVAS.width - 100;
            this.state.players.p2.ult = 0;
            this.state.players.p2.slowUntil = 0;
            this.state.remainingTime = GAME_DURATION;
            this.state.startTime = now;
            this.state.status = "playing";
            this.localBullets = []; 

            await updateDoc(doc(db, "rooms", this.roomId), {
                "players.p1.hp": 100,
                "players.p1.x": 100,
                "players.p1.ult": 0,
                "players.p2.hp": 100,
                "players.p2.x": CANVAS.width - 100,
                "players.p2.ult": 0,
                "status": "playing",
                "remainingTime": GAME_DURATION,
                "startTime": now,
                "winner": null
            });
        }

        async disbandRoom() {
            if (!this.isHost) return;
            try {
                await updateDoc(doc(db, "rooms", this.roomId), { status: "closed" });
                location.reload();
            } catch (e) { console.error("Disband Error:", e); }
        }

        draw() {
            CTX.fillStyle = '#222';
            CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

            // Players
            ['p1', 'p2'].forEach(pid => {
                const p = this.state.players[pid];
                if (!p.active) return;
                
                CTX.beginPath();
                CTX.arc(p.x, p.y, PLAYER_RADIUS, 0, Math.PI*2);
                CTX.fillStyle = pid === 'p1' ? '#00ccff' : '#00ff00';
                CTX.fill();
                
                if (Date.now() < p.slowUntil) {
                    CTX.strokeStyle = '#00ffff';
                    CTX.lineWidth = 3;
                    CTX.stroke();
                } else {
                    CTX.strokeStyle = 'white';
                    CTX.lineWidth = 2;
                    CTX.stroke();
                }
            });

            // Particles
            this.particles.forEach(p => {
                CTX.beginPath();
                CTX.arc(p.x, p.y, p.size || 3, 0, Math.PI*2);
                CTX.fillStyle = p.color;
                CTX.fill();
            });

            // Bullets
            this.localBullets.forEach(b => {
                CTX.beginPath();
                CTX.arc(b.x, b.y, b.r, 0, Math.PI*2);
                if (b.isUlt) {
                    CTX.fillStyle = '#d000ff';
                    CTX.shadowBlur = 10;
                    CTX.shadowColor = '#d000ff';
                } else {
                    CTX.fillStyle = '#ffeb3b';
                    CTX.shadowBlur = 0;
                }
                CTX.fill();
                CTX.shadowBlur = 0;
            });

            // Virtual Sticks
            // Move Stick (Left)
            if (this.input.move.active) {
                this.drawStick(this.input.move.baseX, this.input.move.baseY, this.input.move.x, this.input.move.y);
            }

            // Aim Stick (Right)
            if (this.input.aim.active) {
                this.drawStick(this.input.aim.baseX, this.input.aim.baseY, this.input.aim.x, this.input.aim.y, true);
                
                // エイムライン
                CTX.beginPath();
                CTX.moveTo(this.input.aim.baseX, this.input.aim.baseY);
                CTX.lineTo(
                    this.input.aim.baseX + Math.cos(this.input.aim.angle) * 100, 
                    this.input.aim.baseY + Math.sin(this.input.aim.angle) * 100
                );
                CTX.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                CTX.lineWidth = 2;
                CTX.stroke();
            }
        }

        drawStick(baseX, baseY, inputX, inputY, isAim = false) {
            CTX.beginPath();
            CTX.arc(baseX, baseY, 50, 0, Math.PI*2);
            CTX.strokeStyle = 'rgba(255,255,255,0.3)';
            CTX.lineWidth = 2;
            CTX.stroke();
            CTX.beginPath();
            CTX.arc(baseX + inputX*50, baseY + inputY*50, 25, 0, Math.PI*2);
            CTX.fillStyle = isAim ? 'rgba(255,50,50,0.5)' : 'rgba(255,255,255,0.5)';
            CTX.fill();
        }

        loop(timestamp) {
            this.update();
            this.draw();
            requestAnimationFrame((t) => this.loop(t));
        }

        // --- Inputs ---
        bindButtons() {
            document.getElementById('btn-create').onclick = () => this.createRoom();
            document.getElementById('btn-join').onclick = () => {
                const id = document.getElementById('input-room').value;
                if(id.length === 4) this.joinRoom(id);
                else alert("Enter 4 digits");
            };
            document.getElementById('btn-restart').onclick = () => this.restartGame();
            document.getElementById('btn-close').onclick = () => this.disbandRoom();
            document.getElementById('btn-leave').onclick = () => location.reload();
            document.getElementById('btn-ult').onclick = (e) => {
                e.stopPropagation();
                this.triggerUlt();
            };
        }

        setupInputs() {
            const handleTouch = (e) => {
                e.preventDefault();
                const touches = e.changedTouches;
                for (let i = 0; i < touches.length; i++) {
                    const t = touches[i];
                    const x = t.clientX;
                    const y = t.clientY;

                    // Left side: Move Stick
                    if (x < CANVAS.width / 2) {
                        if (!this.input.move.active) {
                            this.input.move.active = true;
                            this.input.move.id = t.identifier;
                            this.input.move.baseX = x;
                            this.input.move.baseY = y;
                            this.input.move.x = 0;
                            this.input.move.y = 0;
                        } else if (this.input.move.id === t.identifier) {
                            const dx = x - this.input.move.baseX;
                            const dy = y - this.input.move.baseY;
                            const dist = Math.hypot(dx, dy);
                            const max = 50;
                            const angle = Math.atan2(dy, dx);
                            if (dist > max) {
                                this.input.move.x = Math.cos(angle);
                                this.input.move.y = Math.sin(angle);
                            } else {
                                this.input.move.x = dx / max;
                                this.input.move.y = dy / max;
                            }
                            this.input.move.angle = angle;
                        }
                    } 
                    // Right side: Aim Stick
                    else {
                        // ULTボタンエリア除外
                        const ultRect = document.getElementById('btn-ult').getBoundingClientRect();
                        if (x >= ultRect.left && x <= ultRect.right && y >= ultRect.top && y <= ultRect.bottom) {
                            continue;
                        }

                        if (!this.input.aim.active) {
                            this.input.aim.active = true;
                            this.input.aim.id = t.identifier;
                            this.input.aim.baseX = x;
                            this.input.aim.baseY = y;
                            this.input.aim.x = 0;
                            this.input.aim.y = 0;
                        } else if (this.input.aim.id === t.identifier) {
                            const dx = x - this.input.aim.baseX;
                            const dy = y - this.input.aim.baseY;
                            const dist = Math.hypot(dx, dy);
                            const max = 50;
                            const angle = Math.atan2(dy, dx);
                            if (dist > max) {
                                this.input.aim.x = Math.cos(angle);
                                this.input.aim.y = Math.sin(angle);
                            } else {
                                this.input.aim.x = dx / max;
                                this.input.aim.y = dy / max;
                            }
                            this.input.aim.angle = angle;
                        }
                    }
                }
            };

            const handleEnd = (e) => {
                e.preventDefault();
                const touches = e.changedTouches;
                for (let i = 0; i < touches.length; i++) {
                    const t = touches[i];
                    if (this.input.move.id === t.identifier) {
                        this.input.move.active = false;
                        this.input.move.id = null;
                        this.input.move.x = 0;
                        this.input.move.y = 0;
                    }
                    if (this.input.aim.id === t.identifier) {
                        // Fire on release
                        this.triggerFire(this.input.aim.angle);
                        this.input.aim.active = false;
                        this.input.aim.id = null;
                        this.input.aim.x = 0;
                        this.input.aim.y = 0;
                    }
                }
            };

            CANVAS.addEventListener('touchstart', handleTouch, {passive: false});
            CANVAS.addEventListener('touchmove', handleTouch, {passive: false});
            CANVAS.addEventListener('touchend', handleEnd, {passive: false});
        }
    }

    window.onload = () => new Game();
</script>
</body>
</html>
