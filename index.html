<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Shooter - Stock System</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* スクロール禁止 */
            background-color: #222;
            touch-action: none; /* スマホでのピンチズーム等を無効化 */
            font-family: Arial, sans-serif;
            user-select: none; /* テキスト選択禁止 */
            -webkit-user-select: none;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * ユーティリティ: ベクトル計算用
 */
class Vec2 {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

/**
 * InputManagerクラス
 * タッチ操作（仮想スティックとボタン）およびUIタップを管理
 */
class InputManager {
    constructor(canvas) {
        this.canvas = canvas;
        
        // 仮想スティック（左側）
        this.stickBase = new Vec2(150, canvas.height - 150);
        this.stickPos = new Vec2(0, 0);
        this.stickRadius = 60;
        this.knobRadius = 30;
        this.stickActive = false;
        this.stickTouchId = null;
        this.moveVector = new Vec2(0, 0);

        // 射撃ボタン（右側）
        this.btnPos = new Vec2(canvas.width - 150, canvas.height - 150);
        this.btnRadius = 50;
        this.btnActive = false;
        this.btnTouchId = null;

        // UIタップ用（リトライボタン判定などに使用）
        this.lastTap = null;

        this.setupEvents();
    }

    updateLayout(width, height) {
        this.stickBase = new Vec2(120, height - 120);
        this.btnPos = new Vec2(width - 120, height - 120);
    }

    setupEvents() {
        // タッチ開始
        this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                const x = t.clientX;
                const y = t.clientY;

                // UIタップ座標を記録（ゲームオーバー時の判定用）
                this.lastTap = { x: x, y: y };

                // 左画面エリア: スティック操作
                if (x < this.canvas.width / 2 && !this.stickActive) {
                    this.stickActive = true;
                    this.stickTouchId = t.identifier;
                    this.updateStick(x, y);
                }
                // 右画面エリア: 射撃ボタン
                else if (x >= this.canvas.width / 2) {
                    const dist = Math.hypot(x - this.btnPos.x, y - this.btnPos.y);
                    if (dist < 100) { 
                        this.btnActive = true;
                        this.btnTouchId = t.identifier;
                    }
                }
            }
        }, { passive: false });

        // タッチ移動
        this.canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if (t.identifier === this.stickTouchId) {
                    this.updateStick(t.clientX, t.clientY);
                }
            }
        }, { passive: false });

        // タッチ終了
        const endHandler = (e) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if (t.identifier === this.stickTouchId) {
                    this.stickActive = false;
                    this.stickTouchId = null;
                    this.stickPos.x = 0;
                    this.stickPos.y = 0;
                    this.moveVector.x = 0;
                    this.moveVector.y = 0;
                }
                if (t.identifier === this.btnTouchId) {
                    this.btnActive = false;
                    this.btnTouchId = null;
                }
            }
        };
        this.canvas.addEventListener('touchend', endHandler);
        this.canvas.addEventListener('touchcancel', endHandler);
    }

    updateStick(touchX, touchY) {
        let dx = touchX - this.stickBase.x;
        let dy = touchY - this.stickBase.y;
        const dist = Math.hypot(dx, dy);

        if (dist > this.stickRadius) {
            const ratio = this.stickRadius / dist;
            dx *= ratio;
            dy *= ratio;
        }

        this.stickPos.x = dx;
        this.stickPos.y = dy;
        this.moveVector.x = dx / this.stickRadius;
        this.moveVector.y = dy / this.stickRadius;
    }

    // タップ情報のクリア（1フレームごとに呼ぶ）
    clearTap() {
        this.lastTap = null;
    }

    draw(ctx) {
        // スティック
        ctx.beginPath();
        ctx.arc(this.stickBase.x, this.stickBase.y, this.stickRadius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(this.stickBase.x + this.stickPos.x, this.stickBase.y + this.stickPos.y, this.knobRadius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.fill();

        // 射撃ボタン
        ctx.beginPath();
        ctx.arc(this.btnPos.x, this.btnPos.y, this.btnRadius, 0, Math.PI * 2);
        ctx.fillStyle = this.btnActive ? 'rgba(255, 50, 50, 0.8)' : 'rgba(255, 50, 50, 0.4)';
        ctx.fill();
        ctx.strokeStyle = 'white';
        ctx.stroke();
        
        ctx.fillStyle = 'white';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('FIRE', this.btnPos.x, this.btnPos.y);
    }
}

/**
 * Bulletクラス
 */
class Bullet {
    constructor(x, y, vx, vy, isPlayerBullet) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.radius = 5;
        this.isPlayerBullet = isPlayerBullet;
        this.active = true;
    }

    update(width, height) {
        this.x += this.vx;
        this.y += this.vy;
        if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) {
            this.active = false;
        }
    }

    draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.isPlayerBullet ? '#FFFF00' : '#FF00FF';
        ctx.fill();
    }
}

/**
 * Playerクラス
 * 残機、無敵状態の管理を追加
 */
class Player {
    constructor(x, y) {
        this.startX = x; // リスポーン位置用
        this.startY = y;
        this.x = x;
        this.y = y;
        this.radius = 15;
        this.speed = 5;
        
        // ステータス
        this.maxHp = 100;
        this.hp = this.maxHp;
        this.lives = 3; // 残機
        
        // 状態フラグ
        this.isDead = false;         // 死亡中（リスポーン待ち）
        this.invincibleUntil = 0;    // この時間まで無敵

        // 射撃管理
        this.lastShotTime = 0;
        this.shotInterval = 150;
    }

    // リスポーン処理
    respawn() {
        this.x = this.startX;
        this.y = this.startY;
        this.hp = this.maxHp;
        this.isDead = false;
        this.invincibleUntil = Date.now() + 3000; // 3秒間無敵
    }

    // ダメージ処理
    takeDamage(amount) {
        if (this.isDead || this.isInvincible()) return;

        this.hp -= amount;
        if (this.hp <= 0) {
            this.hp = 0;
            this.lives--;
            this.isDead = true;
            // 戻り値で死亡したことを通知
            return true;
        }
        return false;
    }

    isInvincible() {
        return Date.now() < this.invincibleUntil;
    }

    update(input, width, height, bullets) {
        if (this.isDead) return; // 死亡中は操作不可

        // 移動
        this.x += input.moveVector.x * this.speed;
        this.y += input.moveVector.y * this.speed;

        // 画面端の制限
        this.x = Math.max(this.radius, Math.min(width - this.radius, this.x));
        this.y = Math.max(this.radius, Math.min(height - this.radius, this.y));

        // 射撃
        if (input.btnActive) {
            const now = Date.now();
            if (now - this.lastShotTime > this.shotInterval) {
                this.shoot(bullets);
                this.lastShotTime = now;
            }
        }
    }

    shoot(bullets) {
        bullets.push(new Bullet(this.x, this.y - 20, 0, -10, true));
    }

    draw(ctx) {
        if (this.isDead) return;

        ctx.save();
        
        // 無敵中は半透明にする
        if (this.isInvincible()) {
            ctx.globalAlpha = 0.5;
            // 無敵テキスト表示
            ctx.fillStyle = '#FFF';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('INVINCIBLE', this.x, this.y - 25);
        }

        // 本体
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - this.radius);
        ctx.lineTo(this.x + this.radius, this.y + this.radius);
        ctx.lineTo(this.x - this.radius, this.y + this.radius);
        ctx.closePath();
        ctx.fillStyle = '#00CCFF';
        ctx.fill();

        ctx.restore();
    }
}

/**
 * Enemyクラス
 */
class Enemy {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 15;
        this.speed = 2;
        this.active = true;
        this.lastShotTime = Date.now();
        this.shotInterval = 2000;
    }

    update(player, bullets) {
        if (!player.isDead) {
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const dist = Math.hypot(dx, dy);
            
            if (dist > 0) {
                this.x += (dx / dist) * this.speed;
                this.y += (dy / dist) * this.speed;
            }

            const now = Date.now();
            if (now - this.lastShotTime > this.shotInterval) {
                const bulletSpeed = 6;
                bullets.push(new Bullet(this.x, this.y, (dx / dist) * bulletSpeed, (dy / dist) * bulletSpeed, false));
                this.lastShotTime = now;
            }
        }
    }

    draw(ctx) {
        ctx.beginPath();
        ctx.rect(this.x - 15, this.y - 15, 30, 30);
        ctx.fillStyle = '#FF4444';
        ctx.fill();
    }
}

/**
 * Gameクラス
 * リスポーン、ゲームオーバー、リトライ制御を追加
 */
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.input = new InputManager(this.canvas);
        
        this.resize();
        window.addEventListener('resize', () => this.resize());

        this.initGame();

        // ループ開始
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    initGame() {
        // ゲーム状態の初期化
        this.player = new Player(this.canvas.width / 2, this.canvas.height / 2);
        this.bullets = [];
        this.enemies = [];
        this.isGameOver = false;
        this.respawnTimer = 0; // リスポーン待ち時間用
        this.lastSpawnTime = 0;
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        if (this.input) this.input.updateLayout(this.canvas.width, this.canvas.height);
        // 画面サイズ変更時にプレイヤー位置が画面外に行かないようにする等は省略（リスポーン時に中央に戻るため）
    }

    spawnEnemy() {
        const now = Date.now();
        if (now - this.lastSpawnTime > 1500) {
            const x = Math.random() * this.canvas.width;
            const y = -50;
            this.enemies.push(new Enemy(x, y));
            this.lastSpawnTime = now;
        }
    }

    checkCollisions() {
        if (this.isGameOver) return;

        this.bullets.forEach(b => {
            if (!b.active) return;

            if (b.isPlayerBullet) {
                // プレイヤーの弾 -> 敵
                this.enemies.forEach(e => {
                    if (!e.active) return;
                    const dist = Math.hypot(b.x - e.x, b.y - e.y);
                    if (dist < b.radius + e.radius + 10) {
                        e.active = false;
                        b.active = false;
                    }
                });
            } else {
                // 敵の弾 -> プレイヤー
                const dist = Math.hypot(b.x - this.player.x, b.y - this.player.y);
                if (dist < b.radius + this.player.radius) {
                    // ダメージ処理
                    if (this.player.takeDamage(20)) {
                        // 死亡した場合（HP0）
                        b.active = false;
                        this.handlePlayerDeath();
                    } else if (!this.player.isInvincible()) {
                        // 生きていてダメージを受けた場合
                        b.active = false;
                    }
                }
            }
        });
    }

    handlePlayerDeath() {
        if (this.player.lives < 0) {
            this.isGameOver = true;
        } else {
            // 2秒後にリスポーンするためのタイマーセット
            this.respawnTimer = Date.now() + 2000;
        }
    }

    update() {
        // ゲームオーバー時のリトライ判定
        if (this.isGameOver) {
            this.checkRetry();
            this.input.clearTap(); // タップ情報の破棄
            return;
        }

        // リスポーン待ち処理
        if (this.player.isDead) {
            if (Date.now() > this.respawnTimer && this.player.lives >= 0) {
                // 中央位置を再設定してリスポーン
                this.player.startX = this.canvas.width / 2;
                this.player.startY = this.canvas.height / 2;
                this.player.respawn();
            } else if (this.player.lives < 0) {
                this.isGameOver = true;
            }
        }

        this.spawnEnemy();
        this.player.update(this.input, this.canvas.width, this.canvas.height, this.bullets);

        this.bullets.forEach(b => b.update(this.canvas.width, this.canvas.height));
        this.bullets = this.bullets.filter(b => b.active);

        this.enemies.forEach(e => e.update(this.player, this.bullets));
        this.enemies = this.enemies.filter(e => e.active);

        this.checkCollisions();
        
        this.input.clearTap();
    }

    checkRetry() {
        // リトライボタン領域（画面中央下部）
        const btnW = 160;
        const btnH = 50;
        const btnX = this.canvas.width / 2 - btnW / 2;
        const btnY = this.canvas.height / 2 + 60;

        if (this.input.lastTap) {
            const tap = this.input.lastTap;
            if (tap.x >= btnX && tap.x <= btnX + btnW &&
                tap.y >= btnY && tap.y <= btnY + btnH) {
                this.initGame(); // リセット
            }
        }
    }

    drawUI() {
        // HPバー背景
        this.ctx.fillStyle = '#555';
        this.ctx.fillRect(20, 20, 200, 20);
        
        // HPバー現在値
        const hpPercent = this.player.hp / this.player.maxHp;
        this.ctx.fillStyle = hpPercent > 0.3 ? '#00FF00' : '#FF0000';
        this.ctx.fillRect(20, 20, 200 * hpPercent, 20);
        
        // HP枠線
        this.ctx.strokeStyle = '#FFF';
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(20, 20, 200, 20);

        // 残機表示
        this.ctx.fillStyle = '#FFF';
        this.ctx.font = '20px Arial';
        this.ctx.textAlign = 'left';
        this.ctx.fillText(`Lives: ${Math.max(0, this.player.lives)}`, 20, 70);
    }

    drawGameOver() {
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // GAME OVER テキスト
        this.ctx.fillStyle = '#FFF';
        this.ctx.font = 'bold 40px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 20);

        // RETRY ボタン描画
        const btnW = 160;
        const btnH = 50;
        const btnX = this.canvas.width / 2 - btnW / 2;
        const btnY = this.canvas.height / 2 + 60;

        this.ctx.fillStyle = '#FFF';
        this.ctx.fillRect(btnX, btnY, btnW, btnH);

        this.ctx.fillStyle = '#000';
        this.ctx.font = 'bold 24px Arial';
        this.ctx.fillText('RETRY', this.canvas.width / 2, btnY + btnH / 2);
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        if (!this.isGameOver) {
            this.player.draw(this.ctx);
            this.enemies.forEach(e => e.draw(this.ctx));
            this.bullets.forEach(b => b.draw(this.ctx));
            this.drawUI();
            this.input.draw(this.ctx);
        } else {
            this.drawGameOver();
        }
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(this.loop);
    }
}

// ゲーム起動
window.onload = () => {
    new Game();
};

</script>
</body>
</html>
