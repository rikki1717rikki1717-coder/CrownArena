<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Firebase Firestore WebRTC Shooter</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #222;
            touch-action: none;
            font-family: Arial, sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display: block;
        }
        
        /* 接続メニュー用オーバーレイ */
        #menuOverlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 400px;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            color: white;
            display: flex;
            flex-direction: column;
            gap: 15px;
            border: 2px solid #555;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            z-index: 100;
        }
        #menuOverlay h2 { margin: 0 0 10px 0; font-size: 20px; text-align: center; color: #00CCFF; }
        
        input {
            background: #333;
            border: 1px solid #666;
            color: #fff;
            padding: 10px;
            border-radius: 5px;
            font-size: 16px;
            text-align: center;
        }
        button {
            padding: 12px;
            background: #0077ff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            transition: background 0.2s;
        }
        button:active { background: #0055cc; }
        button#btnJoin { background: #00cc66; }
        button#btnJoin:active { background: #009944; }
        
        .room-info {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            color: #FFFF00;
            margin: 10px 0;
            letter-spacing: 2px;
        }
        #statusMsg {
            text-align: center;
            color: #aaa;
            font-size: 12px;
            min-height: 1.2em;
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="menuOverlay">
    <h2>Multiplayer Shooter</h2>
    
    <div id="menuStart">
        <button id="btnCreate" style="width:100%">Create Room</button>
        <div style="text-align:center; margin:10px 0; color:#888;">- OR -</div>
        <div style="display:flex; gap:10px;">
            <input type="number" id="roomIdInput" placeholder="Room ID" style="flex:1;">
            <button id="btnJoin" style="flex:1;">Join</button>
        </div>
    </div>

    <div id="menuWaiting" class="hidden">
        <div style="text-align:center; color:#ddd;">Room Created! Share this ID:</div>
        <div id="roomDisplay" class="room-info">----</div>
        <div style="text-align:center; font-size:12px; color:#888;">Waiting for opponent...</div>
    </div>

    <div id="statusMsg">Ready to connect</div>
</div>

<canvas id="gameCanvas"></canvas>

<script type="module">
    // --- Firebase Imports ---
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
    import { 
        getFirestore, 
        collection, 
        doc, 
        setDoc, 
        getDoc, 
        updateDoc, 
        onSnapshot, 
        addDoc 
    } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

    // --- Firebase Configuration ---
    const firebaseConfig = {
      apiKey: "AIzaSyA8B-JtwDskK3omhjUCbjERHBZ6UDdm854",
      authDomain: "crownarena-1a321.firebaseapp.com",
      projectId: "crownarena-1a321",
      storageBucket: "crownarena-1a321.firebasestorage.app",
      messagingSenderId: "103440875843",
      appId: "1:103440875843:web:d34b314c4df7e0d491aff6",
      measurementId: "G-N9KDL9B9Y5"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    /**
     * NetworkManagerクラス
     * Firestoreを使った自動シグナリング管理
     */
    class NetworkManager {
        constructor() {
            this.pc = null;
            this.dc = null;
            this.roomId = null;
            this.isConnected = false;
            
            this.config = {
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            };

            // コールバック
            this.onConnected = () => {};
            this.onMessage = (msg) => {};
            this.onStatusChange = (msg) => {};
        }

        // 共通: PeerConnectionの初期化
        createPeerConnection() {
            this.pc = new RTCPeerConnection(this.config);
            
            this.pc.onconnectionstatechange = () => {
                console.log("Connection State:", this.pc.connectionState);
            };
        }

        // DataChannelのセットアップ
        setupDataChannel(channel) {
            this.dc = channel;
            this.dc.onopen = () => {
                console.log("DataChannel OPEN");
                this.isConnected = true;
                this.onStatusChange("Connected!");
                this.onConnected();
            };
            this.dc.onmessage = (event) => {
                this.onMessage(event.data);
            };
        }

        // ICE Candidateの収集とFirestoreへの保存
        registerPeerConnectionListeners(localName, remoteName) {
            // 自分のCandidateをFirestoreに保存
            this.pc.onicecandidate = async (event) => {
                if (event.candidate) {
                    const candidatesCollection = collection(db, 'rooms', this.roomId, localName);
                    await addDoc(candidatesCollection, event.candidate.toJSON());
                }
            };

            // 相手のCandidateをFirestoreから取得
            const candidatesCollection = collection(db, 'rooms', this.roomId, remoteName);
            onSnapshot(candidatesCollection, (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === 'added') {
                        const data = change.doc.data();
                        const candidate = new RTCIceCandidate(data);
                        try {
                            await this.pc.addIceCandidate(candidate);
                        } catch (e) {
                            console.error("Error adding ice candidate", e);
                        }
                    }
                });
            });
        }

        // Hostとして部屋を作成
        async createRoom() {
            this.createPeerConnection();
            
            // HostがDataChannel作成
            const channel = this.pc.createDataChannel("gameChannel");
            this.setupDataChannel(channel);

            // ルームID生成 (ランダム4桁)
            this.roomId = Math.floor(1000 + Math.random() * 9000).toString();
            
            // Offer生成
            const offer = await this.pc.createOffer();
            await this.pc.setLocalDescription(offer);

            // Firestoreに部屋作成 (Offer保存)
            const roomRef = doc(db, 'rooms', this.roomId);
            const roomWithOffer = {
                offer: {
                    type: offer.type,
                    sdp: offer.sdp
                }
            };
            await setDoc(roomRef, roomWithOffer);

            this.onStatusChange(`Room ${this.roomId} created. Waiting...`);

            // ICE処理開始 (Hostは 'callerCandidates' に書き込み、'calleeCandidates' をリッスン)
            this.registerPeerConnectionListeners('callerCandidates', 'calleeCandidates');

            // Answer待ち (Joinerが参加するのを監視)
            onSnapshot(roomRef, async (snapshot) => {
                const data = snapshot.data();
                if (!this.pc.currentRemoteDescription && data && data.answer) {
                    const answer = new RTCSessionDescription(data.answer);
                    await this.pc.setRemoteDescription(answer);
                    this.onStatusChange("Connecting...");
                }
            });

            return this.roomId;
        }

        // Joinerとして部屋に参加
        async joinRoom(roomId) {
            this.roomId = roomId;
            const roomRef = doc(db, 'rooms', roomId);
            const roomSnapshot = await getDoc(roomRef);

            if (!roomSnapshot.exists()) {
                throw new Error("Room not found");
            }

            this.createPeerConnection();

            // JoinerはDataChannelを受け取る
            this.pc.ondatachannel = (event) => {
                this.setupDataChannel(event.channel);
            };

            // Offer取得 & 設定
            const offer = roomSnapshot.data().offer;
            await this.pc.setRemoteDescription(new RTCSessionDescription(offer));

            // Answer生成
            const answer = await this.pc.createAnswer();
            await this.pc.setLocalDescription(answer);

            // FirestoreにAnswer保存
            const roomWithAnswer = {
                answer: {
                    type: answer.type,
                    sdp: answer.sdp
                }
            };
            await updateDoc(roomRef, roomWithAnswer);

            // ICE処理開始 (Joinerは 'calleeCandidates' に書き込み、'callerCandidates' をリッスン)
            this.registerPeerConnectionListeners('calleeCandidates', 'callerCandidates');

            this.onStatusChange("Joining... Connecting to host.");
        }
    }


    /**
     * 既存のゲームクラス構造 (UI制御以外は変更なし)
     */
    class Vec2 {
        constructor(x, y) { this.x = x; this.y = y; }
    }

    class InputManager {
        constructor(canvas) {
            this.canvas = canvas;
            this.p1 = {
                moveVector: new Vec2(0, 0), btnActive: false,
                stickBase: new Vec2(150, canvas.height - 150), stickPos: new Vec2(0, 0),
                stickRadius: 60, btnPos: new Vec2(canvas.width - 150, canvas.height - 150),
                btnRadius: 50, stickTouchId: null, btnTouchId: null
            };
            this.p2 = {
                moveVector: new Vec2(0, 0), btnActive: false,
                buttons: [], activeTouches: {}
            };
            this.lastTap = null;
            this.updateLayout(canvas.width, canvas.height);
            this.setupEvents();
        }
        updateLayout(width, height) {
            this.p1.stickBase = new Vec2(120, height - 120);
            this.p1.btnPos = new Vec2(width - 120, height - 120);
            const size = 40, gap = 5, baseX = width - 180, baseY = 20;
            this.p2.buttons = [
                { id: 'U', x: baseX + size + gap, y: baseY, w: size, h: size },
                { id: 'L', x: baseX, y: baseY + size + gap, w: size, h: size },
                { id: 'D', x: baseX + size + gap, y: baseY + (size + gap) * 2, w: size, h: size },
                { id: 'R', x: baseX + (size + gap) * 2, y: baseY + size + gap, w: size, h: size },
                { id: 'F', x: baseX + (size + gap) * 3 + 20, y: baseY + size + gap, w: 50, h: 50 }
            ];
        }
        setupEvents() {
            const handleTouch = (e, type) => {
                if(e.target.tagName !== 'CANVAS') return;
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    const x = t.clientX;
                    const y = t.clientY;
                    if (type === 'start') {
                        this.lastTap = { x: x, y: y };
                        if (x < this.canvas.width / 2 && y > this.canvas.height / 2 && !this.p1.stickActive) {
                            this.p1.stickActive = true;
                            this.p1.stickTouchId = t.identifier;
                            this.updateP1Stick(x, y);
                        } else if (x >= this.canvas.width / 2 && y > this.canvas.height / 2) {
                            const dist = Math.hypot(x - this.p1.btnPos.x, y - this.p1.btnPos.y);
                            if (dist < 100) {
                                this.p1.btnActive = true;
                                this.p1.btnTouchId = t.identifier;
                            }
                        }
                        this.p2.buttons.forEach(btn => {
                            if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                                this.p2.activeTouches[t.identifier] = btn.id;
                            }
                        });
                        this.updateP2Input();
                    } else if (type === 'move') {
                        if (t.identifier === this.p1.stickTouchId) this.updateP1Stick(x, y);
                    } else if (type === 'end') {
                        if (t.identifier === this.p1.stickTouchId) {
                            this.p1.stickActive = false;
                            this.p1.stickTouchId = null;
                            this.p1.stickPos.x = 0; this.p1.stickPos.y = 0;
                            this.p1.moveVector.x = 0; this.p1.moveVector.y = 0;
                        }
                        if (t.identifier === this.p1.btnTouchId) {
                            this.p1.btnActive = false;
                            this.p1.btnTouchId = null;
                        }
                        if (this.p2.activeTouches[t.identifier]) {
                            delete this.p2.activeTouches[t.identifier];
                            this.updateP2Input();
                        }
                    }
                }
            };
            this.canvas.addEventListener('touchstart', (e) => handleTouch(e, 'start'), { passive: false });
            this.canvas.addEventListener('touchmove', (e) => handleTouch(e, 'move'), { passive: false });
            this.canvas.addEventListener('touchend', (e) => handleTouch(e, 'end'), { passive: false });
            this.canvas.addEventListener('touchcancel', (e) => handleTouch(e, 'end'), { passive: false });
        }
        updateP1Stick(touchX, touchY) {
            let dx = touchX - this.p1.stickBase.x;
            let dy = touchY - this.p1.stickBase.y;
            const dist = Math.hypot(dx, dy);
            if (dist > this.p1.stickRadius) {
                const ratio = this.p1.stickRadius / dist;
                dx *= ratio; dy *= ratio;
            }
            this.p1.stickPos.x = dx; this.p1.stickPos.y = dy;
            this.p1.moveVector.x = dx / this.p1.stickRadius;
            this.p1.moveVector.y = dy / this.p1.stickRadius;
        }
        updateP2Input() {
            let vx = 0, vy = 0, fire = false;
            Object.values(this.p2.activeTouches).forEach(btnId => {
                if (btnId === 'U') vy = -1; if (btnId === 'D') vy = 1;
                if (btnId === 'L') vx = -1; if (btnId === 'R') vx = 1;
                if (btnId === 'F') fire = true;
            });
            if (vx !== 0 && vy !== 0) { const len = Math.hypot(vx, vy); vx /= len; vy /= len; }
            this.p2.moveVector.x = vx; this.p2.moveVector.y = vy;
            this.p2.btnActive = fire;
        }
        clearTap() { this.lastTap = null; }
        draw(ctx) {
            ctx.beginPath(); ctx.arc(this.p1.stickBase.x, this.p1.stickBase.y, this.p1.stickRadius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)'; ctx.fill();
            ctx.strokeStyle = 'rgba(100, 100, 255, 0.5)'; ctx.stroke();
            ctx.beginPath(); ctx.arc(this.p1.stickBase.x + this.p1.stickPos.x, this.p1.stickBase.y + this.p1.stickPos.y, 30, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(100, 100, 255, 0.8)'; ctx.fill();
            ctx.beginPath(); ctx.arc(this.p1.btnPos.x, this.p1.btnPos.y, this.p1.btnRadius, 0, Math.PI * 2);
            ctx.fillStyle = this.p1.btnActive ? 'rgba(100, 100, 255, 0.8)' : 'rgba(100, 100, 255, 0.4)'; ctx.fill();
            ctx.strokeStyle = 'white'; ctx.stroke();
            ctx.fillStyle = 'white'; ctx.font = '16px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText('P1 FIRE', this.p1.btnPos.x, this.p1.btnPos.y);
            this.p2.buttons.forEach(btn => {
                ctx.fillStyle = 'rgba(100, 255, 100, 0.5)';
                if (Object.values(this.p2.activeTouches).includes(btn.id)) ctx.fillStyle = 'rgba(100, 255, 100, 0.9)';
                ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
                ctx.fillStyle = '#000'; ctx.font = '12px Arial';
                ctx.fillText(btn.id, btn.x + btn.w/2, btn.y + btn.h/2);
            });
            ctx.fillStyle = '#FFF'; ctx.fillText("P2", this.canvas.width - 50, 15);
        }
    }

    class Bullet {
        constructor(x, y, vx, vy, ownerId) {
            this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.radius = 6; this.ownerId = ownerId; this.active = true;
        }
        update(width, height) {
            this.x += this.vx; this.y += this.vy;
            if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) this.active = false;
        }
        draw(ctx) {
            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            if (this.ownerId === 1) ctx.fillStyle = '#8888FF'; else if (this.ownerId === 2) ctx.fillStyle = '#88FF88'; else ctx.fillStyle = '#FF00FF';
            ctx.fill();
        }
    }

    class Player {
        constructor(id, x, y, color) {
            this.id = id; this.startX = x; this.startY = y; this.x = x; this.y = y; this.color = color;
            this.radius = 15; this.speed = 5; this.maxHp = 100; this.hp = this.maxHp; this.lives = 3;
            this.isDead = false; this.invincibleUntil = 0; this.lastShotTime = 0; this.shotInterval = 150;
        }
        respawn() {
            this.x = this.startX; this.y = this.startY; this.hp = this.maxHp; this.isDead = false;
            this.invincibleUntil = Date.now() + 3000;
        }
        takeDamage(amount) {
            if (this.isDead || this.isInvincible()) return false;
            this.hp -= amount;
            if (this.hp <= 0) { this.hp = 0; this.lives--; this.isDead = true; return true; }
            return false;
        }
        isInvincible() { return Date.now() < this.invincibleUntil; }
        update(inputData, width, height, bullets) {
            if (this.isDead) return;
            this.x += inputData.moveVector.x * this.speed;
            this.y += inputData.moveVector.y * this.speed;
            this.x = Math.max(this.radius, Math.min(width - this.radius, this.x));
            this.y = Math.max(this.radius, Math.min(height - this.radius, this.y));
            if (inputData.btnActive) {
                const now = Date.now();
                if (now - this.lastShotTime > this.shotInterval) { this.shoot(bullets); this.lastShotTime = now; }
            }
        }
        shoot(bullets) {
            let vx = 0; const speed = 12;
            if (this.id === 1) vx = speed; if (this.id === 2) vx = -speed;
            bullets.push(new Bullet(this.x, this.y, vx, 0, this.id));
        }
        draw(ctx) {
            if (this.isDead) return;
            ctx.save();
            if (this.isInvincible()) {
                ctx.globalAlpha = 0.5; ctx.fillStyle = '#FFF'; ctx.font = '10px Arial';
                ctx.textAlign = 'center'; ctx.fillText('INVINCIBLE', this.x, this.y - 25);
            }
            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.color; ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            if (this.id === 1) ctx.fillRect(this.x, this.y - 5, 10, 10);
            if (this.id === 2) ctx.fillRect(this.x - 10, this.y - 5, 10, 10);
            ctx.restore();
        }
    }

    class Enemy {
        constructor(x, y) {
            this.x = x; this.y = y; this.radius = 15; this.speed = 2; this.active = true;
            this.lastShotTime = Date.now(); this.shotInterval = 2000;
        }
        update(player, bullets) {
            if (!player.isDead) {
                const dx = player.x - this.x; const dy = player.y - this.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 0) { this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; }
                const now = Date.now();
                if (now - this.lastShotTime > this.shotInterval) {
                    const bulletSpeed = 6;
                    bullets.push(new Bullet(this.x, this.y, (dx / dist) * bulletSpeed, (dy / dist) * bulletSpeed, false));
                    this.lastShotTime = now;
                }
            }
        }
        draw(ctx) {
            ctx.beginPath(); ctx.rect(this.x - 15, this.y - 15, 30, 30);
            ctx.fillStyle = '#FF4444'; ctx.fill();
        }
    }

    class Game {
        constructor() {
            this.canvas = document.getElementById('gameCanvas');
            this.ctx = this.canvas.getContext('2d');
            this.input = new InputManager(this.canvas);
            
            this.network = new NetworkManager();
            this.network.onConnected = () => {
                document.getElementById('menuOverlay').style.display = 'none';
            };
            this.network.onStatusChange = (msg) => {
                document.getElementById('statusMsg').innerText = msg;
            };

            this.setupMenuUI();
            this.resize();
            window.addEventListener('resize', () => this.resize());
            this.initGame();
            this.loop = this.loop.bind(this);
            requestAnimationFrame(this.loop);
        }

        setupMenuUI() {
            const menuStart = document.getElementById('menuStart');
            const menuWaiting = document.getElementById('menuWaiting');
            const btnCreate = document.getElementById('btnCreate');
            const btnJoin = document.getElementById('btnJoin');
            const roomIdInput = document.getElementById('roomIdInput');
            const roomDisplay = document.getElementById('roomDisplay');

            // HOST処理
            btnCreate.onclick = async () => {
                btnCreate.disabled = true;
                btnJoin.disabled = true;
                const roomId = await this.network.createRoom();
                
                menuStart.classList.add('hidden');
                menuWaiting.classList.remove('hidden');
                roomDisplay.innerText = roomId;
            };

            // JOIN処理
            btnJoin.onclick = async () => {
                const roomId = roomIdInput.value.trim();
                if (roomId.length !== 4) {
                    alert('Please enter a valid 4-digit Room ID.');
                    return;
                }
                
                btnCreate.disabled = true;
                btnJoin.disabled = true;
                try {
                    await this.network.joinRoom(roomId);
                } catch (e) {
                    alert('Error joining room: ' + e.message);
                    btnCreate.disabled = false;
                    btnJoin.disabled = false;
                }
            };
        }

        initGame() {
            this.p1 = new Player(1, 100, this.canvas.height / 2, '#00CCFF');
            this.p2 = new Player(2, this.canvas.width - 100, this.canvas.height / 2, '#00FF66');
            this.bullets = [];
            this.enemies = [];
            this.winner = null;
            this.isGameOver = false;
            this.p1RespawnTimer = 0;
            this.p2RespawnTimer = 0;
            this.lastSpawnTime = 0;
        }

        resize() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            if (this.input) this.input.updateLayout(this.canvas.width, this.canvas.height);
        }

        checkCollisions() {
            if (this.isGameOver) return;
            this.bullets.forEach(b => {
                if (!b.active) return;
                let target = null;
                if (b.ownerId === 1) target = this.p2;
                else if (b.ownerId === 2) target = this.p1;
                
                this.enemies.forEach(e => {
                    if (e.active && (b.ownerId === 1 || b.ownerId === 2)) {
                        if (Math.hypot(b.x - e.x, b.y - e.y) < b.radius + e.radius + 10) {
                            e.active = false; b.active = false;
                        }
                    }
                });

                if (target && !target.isDead) {
                    const dist = Math.hypot(b.x - target.x, b.y - target.y);
                    if (dist < b.radius + target.radius) {
                        b.active = false;
                        if (target.takeDamage(20)) this.handlePlayerDeath(target);
                    }
                }
            });
        }

        handlePlayerDeath(player) {
            if (player.lives < 0) {
                this.isGameOver = true;
                this.winner = (player.id === 1) ? 2 : 1;
            } else {
                const respawnTime = Date.now() + 2000;
                if (player.id === 1) this.p1RespawnTimer = respawnTime;
                else this.p2RespawnTimer = respawnTime;
            }
        }

        update() {
            if (this.isGameOver) {
                this.checkRetry();
                this.input.clearTap();
                return;
            }

            if (this.p1.isDead && this.p1.lives >= 0 && Date.now() > this.p1RespawnTimer) this.p1.respawn();
            if (this.p2.isDead && this.p2.lives >= 0 && Date.now() > this.p2RespawnTimer) this.p2.respawn();

            const now = Date.now();
            if (now - this.lastSpawnTime > 3000) {
                 this.enemies.push(new Enemy(Math.random()*this.canvas.width, -50));
                 this.lastSpawnTime = now;
            }

            this.p1.update(this.input.p1, this.canvas.width, this.canvas.height, this.bullets);
            this.p2.update(this.input.p2, this.canvas.width, this.canvas.height, this.bullets);

            this.bullets.forEach(b => b.update(this.canvas.width, this.canvas.height));
            this.bullets = this.bullets.filter(b => b.active);
            
            this.enemies.forEach(e => e.update(this.p1, this.bullets));
            this.enemies = this.enemies.filter(e => e.active);

            this.checkCollisions();
            this.input.clearTap();
        }

        checkRetry() {
            const btnW = 160, btnH = 50;
            const btnX = this.canvas.width / 2 - btnW / 2;
            const btnY = this.canvas.height / 2 + 80;
            if (this.input.lastTap) {
                const tap = this.input.lastTap;
                if (tap.x >= btnX && tap.x <= btnX + btnW && tap.y >= btnY && tap.y <= btnY + btnH) {
                    this.initGame();
                }
            }
        }

        drawUI() {
            const drawBar = (player, x, y) => {
                const width = 150, height = 15;
                this.ctx.fillStyle = '#555'; this.ctx.fillRect(x, y, width, height);
                const hpPercent = player.hp / player.maxHp;
                this.ctx.fillStyle = player.id === 1 ? '#00CCFF' : '#00FF66';
                this.ctx.fillRect(x, y, width * hpPercent, height);
                this.ctx.strokeStyle = '#FFF'; this.ctx.strokeRect(x, y, width, height);
                this.ctx.fillStyle = '#FFF'; this.ctx.font = '14px Arial'; ctx.textAlign = 'left';
                this.ctx.fillText(`P${player.id} Lives: ${Math.max(0, player.lives)}`, x, y + 30);
            };
            drawBar(this.p1, 20, 20);
            drawBar(this.p2, this.canvas.width - 170, 20);

            if (this.network.isConnected) {
                this.ctx.fillStyle = '#00FF00';
                this.ctx.font = 'bold 20px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('CONNECTED', this.canvas.width / 2, 30);
            }
        }

        drawGameOver() {
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.fillStyle = this.winner === 1 ? '#00CCFF' : '#00FF66';
            this.ctx.font = 'bold 40px Arial'; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle';
            this.ctx.fillText(`PLAYER ${this.winner} WINS!`, this.canvas.width / 2, this.canvas.height / 2 - 20);
            const btnW = 160, btnH = 50, btnX = this.canvas.width / 2 - btnW / 2, btnY = this.canvas.height / 2 + 80;
            this.ctx.fillStyle = '#FFF'; this.ctx.fillRect(btnX, btnY, btnW, btnH);
            this.ctx.fillStyle = '#000'; this.ctx.font = 'bold 24px Arial';
            this.ctx.fillText('RETRY', this.canvas.width / 2, btnY + btnH / 2);
        }

        draw() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            if (!this.isGameOver) {
                this.p1.draw(this.ctx);
                this.p2.draw(this.ctx);
                this.enemies.forEach(e => e.draw(this.ctx));
                this.bullets.forEach(b => b.draw(this.ctx));
                this.drawUI();
                this.input.draw(this.ctx);
            } else {
                this.drawGameOver();
            }
        }

        loop() {
            this.update();
            this.draw();
            requestAnimationFrame(this.loop);
        }
    }

    // Start Game
    window.onload = () => { new Game(); };
</script>
</body>
</html>
