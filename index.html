<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Firestore Shooter Event-Driven</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            color: white;
            font-family: 'Segoe UI', monospace;
            touch-action: none;
            user-select: none;
        }

        canvas {
            display: block;
        }

        /* 共通パネルスタイル */
        .layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10;
            transition: opacity 0.3s;
        }

        .panel {
            background: #2a2a2a;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid #444;
            width: 320px;
            max-width: 90%;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }

        h1 { margin: 0 0 20px 0; color: #00e5ff; font-size: 24px; }
        h2 { margin: 0 0 15px 0; font-size: 36px; font-weight: bold; }

        input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 6px;
            font-size: 16px;
            text-align: center;
        }

        button {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            color: white;
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.98); }

        .btn-host { background: #0078d7; }
        .btn-join { background: #107c10; }
        .btn-restart { background: #e6c200; color: black; }
        .btn-close { background: #d32f2f; }

        #room-display {
            font-size: 32px;
            font-weight: bold;
            color: #ffeb3b;
            letter-spacing: 5px;
            margin: 15px 0;
            background: #000;
            padding: 10px;
            border-radius: 4px;
        }

        .win { color: #00ff00; }
        .lose { color: #ff0000; }

        /* HUD */
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            font-size: 14px;
            text-shadow: 1px 1px 2px black;
            z-index: 5;
        }
        
        .hp-bar-container {
            width: 100px;
            height: 10px;
            background: #555;
            margin-bottom: 5px;
            border: 1px solid #fff;
        }
        .hp-fill {
            height: 100%;
            background: #0f0;
            width: 100%;
            transition: width 0.2s;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="layer-menu" class="layer">
        <div class="panel">
            <h1>Firestore Shooter</h1>
            <button class="btn-host" id="btn-create">Create Room (Host)</button>
            <div style="margin: 10px 0; color:#666;">- OR -</div>
            <input type="number" id="input-room" placeholder="4-Digit Room ID">
            <button class="btn-join" id="btn-join">Join Room</button>
            <div id="status-msg" style="margin-top:10px; color:#aaa; font-size:12px;">Ready</div>
        </div>
    </div>

    <div id="layer-wait" class="layer hidden">
        <div class="panel">
            <h1>Waiting for Player...</h1>
            <div>Room ID</div>
            <div id="room-display">----</div>
            <div style="font-size: 12px; color: #aaa;">Share this ID</div>
        </div>
    </div>

    <div id="layer-result" class="layer hidden">
        <div class="panel">
            <h2 id="result-title">RESULT</h2>
            <div id="result-msg" style="margin-bottom:20px;"></div>
            
            <div id="host-controls" class="hidden">
                <button class="btn-restart" id="btn-restart">Play Again</button>
                <button class="btn-close" id="btn-close">Disband Room</button>
            </div>
            
            <div id="guest-controls" class="hidden">
                <div style="color:#aaa; margin-bottom:10px;">Waiting for Host...</div>
                <button class="btn-close" id="btn-leave">Leave Room</button>
            </div>
        </div>
    </div>

    <div id="hud">
        <div>
            P1 (Blue) HP: <span id="text-hp-p1">100</span>
            <div class="hp-bar-container"><div id="bar-hp-p1" class="hp-fill"></div></div>
        </div>
        <div>
            P2 (Green) HP: <span id="text-hp-p2">100</span>
            <div class="hp-bar-container"><div id="bar-hp-p2" class="hp-fill"></div></div>
        </div>
        <div style="margin-top:5px; color:#aaa;">Room: <span id="hud-room">----</span></div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script type="module">
    // ---------------------------------------------------------
    // 1. Firebase Config & Imports
    // ---------------------------------------------------------
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { 
        getFirestore, doc, setDoc, updateDoc, onSnapshot, getDoc, deleteDoc, increment 
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    const firebaseConfig = {
        apiKey: "AIzaSyA8B-JtwDskK3omhjUCbjERHBZ6UDdm854",
        authDomain: "crownarena-1a321.firebaseapp.com",
        projectId: "crownarena-1a321",
        storageBucket: "crownarena-1a321.firebasestorage.app",
        messagingSenderId: "103440875843",
        appId: "1:103440875843:web:d34b314c4df7e0d491aff6",
        measurementId: "G-N9KDL9B9Y5"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // ---------------------------------------------------------
    // 2. Constants & Globals
    // ---------------------------------------------------------
    const CANVAS = document.getElementById('gameCanvas');
    const CTX = CANVAS.getContext('2d');
    
    // Game Config
    const PLAYER_RADIUS = 20;
    const BULLET_RADIUS = 6;
    const MOVE_SPEED = 5;
    const BULLET_SPEED = 12;
    const FIRE_RATE = 200; // ms
    const SYNC_INTERVAL = 50; // ms

    // ---------------------------------------------------------
    // 3. Game Logic Class
    // ---------------------------------------------------------
    class Game {
        constructor() {
            this.roomId = null;
            this.isHost = false; 
            this.myId = null; // 'p1' or 'p2'
            
            // ゲーム状態
            this.state = {
                players: {
                    p1: { x: 100, y: 100, hp: 100, active: false, lastFire: 0 },
                    p2: { x: 300, y: 100, hp: 100, active: false, lastFire: 0 }
                },
                status: "waiting", // waiting, playing, finished
                winner: null,
                bulletSeq: 0 // 受信した最新の弾丸シーケンス番号
            };

            this.localBullets = []; // 弾丸は完全にローカル管理

            // Input
            this.input = { x: 0, y: 0, fire: false, firedPressed: false };
            this.touchId = null;
            this.stickBase = { x: 100, y: 300 };
            
            // Timers
            this.lastSyncTime = 0;
            this.unsubscribe = null;
            this.isRoomReady = false;

            this.resize();
            window.addEventListener('resize', () => this.resize());
            this.setupInputs();
            
            // UI Elements
            this.layers = {
                menu: document.getElementById('layer-menu'),
                wait: document.getElementById('layer-wait'),
                result: document.getElementById('layer-result')
            };
            
            this.bindButtons();

            // Loop
            requestAnimationFrame((t) => this.loop(t));
        }

        resize() {
            CANVAS.width = window.innerWidth;
            CANVAS.height = window.innerHeight;
            this.stickBase = { x: 120, y: CANVAS.height - 120 };
        }

        // --- Network Actions ---

        async createRoom() {
            this.roomId = Math.floor(1000 + Math.random() * 9000).toString();
            this.isHost = true;
            this.myId = 'p1';
            
            this.state.players.p1.active = true;
            this.state.players.p1.x = 100;
            this.state.players.p1.hp = 100;

            const initialData = {
                players: {
                    p1: { x: 100, y: 100, hp: 100, active: true },
                    p2: { x: 300, y: 100, hp: 100, active: false }
                },
                status: "waiting",
                winner: null,
                bulletSeq: 0,      // 弾丸発射カウンター
                lastShooter: null  // 最後に撃った人
            };

            try {
                await setDoc(doc(db, "rooms", this.roomId), initialData);
                this.isRoomReady = true;
                this.switchLayer('wait');
                document.getElementById('room-display').innerText = this.roomId;
                document.getElementById('hud-room').innerText = this.roomId;
                this.subscribeToRoom();
            } catch (e) {
                alert("Error: " + e.message);
            }
        }

        async joinRoom(id) {
            const docRef = doc(db, "rooms", id);
            try {
                const snap = await getDoc(docRef);
                if (!snap.exists()) { alert("Room not found!"); return; }

                this.roomId = id;
                this.isHost = false;
                this.myId = 'p2';

                this.state.players.p2.active = true;
                this.state.players.p2.x = CANVAS.width - 100;
                this.state.players.p2.hp = 100;

                await updateDoc(docRef, {
                    "players.p2.active": true,
                    "players.p2.x": this.state.players.p2.x,
                    "status": "playing"
                });

                document.getElementById('hud-room').innerText = this.roomId;
                this.isRoomReady = true;
                this.subscribeToRoom();

            } catch (e) {
                alert("Error joining: " + e.message);
            }
        }

        subscribeToRoom() {
            if (this.unsubscribe) this.unsubscribe();
            
            this.unsubscribe = onSnapshot(doc(db, "rooms", this.roomId), (docSnap) => {
                if (!docSnap.exists()) {
                    if (this.isRoomReady) { alert("Room disbanded."); location.reload(); }
                    return;
                }
                const data = docSnap.data();
                
                // 1. ステータス同期
                if (data.status === "playing") {
                    this.switchLayer(null);
                    this.state.status = "playing";
                } else if (data.status === "finished") {
                    this.state.status = "finished";
                    this.showResult(data.winner);
                }

                // 2. 弾丸同期 (イベント検知)
                // サーバーの bulletSeq が増えていれば、新しい弾が撃たれたということ
                if (data.bulletSeq > this.state.bulletSeq) {
                    // 自分以外が撃った弾なら生成する (自分のは発射時に即生成済み)
                    if (data.lastShooter !== this.myId) {
                        this.spawnBulletFromSync(data.lastShooter);
                    }
                    this.state.bulletSeq = data.bulletSeq;
                }

                // 3. プレイヤー同期
                if (this.isHost) {
                    // Host: P2の位置のみ受信
                    if (data.players.p2) {
                        const p2 = this.state.players.p2;
                        p2.x = data.players.p2.x;
                        p2.y = data.players.p2.y;
                        p2.active = data.players.p2.active;
                    }
                } else {
                    // Guest: P1の位置・HPと、自分のHP(Host計算)を受信
                    if (data.players.p1) {
                        Object.assign(this.state.players.p1, data.players.p1);
                    }
                    if (data.players.p2) {
                        this.state.players.p2.hp = data.players.p2.hp; // Hostが減らしたHP
                        this.state.players.p2.active = data.players.p2.active;
                    }
                }
                this.updateHUD();
            });
        }

        async syncToFirestore() {
            if (!this.roomId || this.state.status === "finished") return;
            const ref = doc(db, "rooms", this.roomId);
            const me = this.state.players[this.myId];

            try {
                if (this.isHost) {
                    await updateDoc(ref, {
                        "players.p1.x": me.x,
                        "players.p1.y": me.y,
                        "players.p1.hp": this.state.players.p1.hp, // 自分のHPもHostが管理
                        "players.p2.hp": this.state.players.p2.hp  // 相手のHPもHostが管理
                    });
                } else {
                    await updateDoc(ref, {
                        "players.p2.x": me.x,
                        "players.p2.y": me.y
                    });
                }
            } catch (e) { /* ignore lag */ }
        }

        // --- Bullet Logic (Event Driven) ---

        // 自分が撃つとき (ローカル即生成 + DB更新)
        async triggerFire() {
            const now = Date.now();
            const me = this.state.players[this.myId];
            
            // クールダウンチェック
            if (now - (me.lastFire || 0) < FIRE_RATE) return;
            me.lastFire = now;

            // 1. ローカルで即座に弾を出す (Client Prediction)
            this.spawnBulletLocal(this.myId);

            // 2. Firestoreのカウンターを増やす
            const ref = doc(db, "rooms", this.roomId);
            try {
                await updateDoc(ref, {
                    bulletSeq: increment(1),
                    lastShooter: this.myId
                });
            } catch (e) { console.error("Fire error", e); }
        }

        // 相手が撃ったとき (Snapshot検知で生成)
        spawnBulletFromSync(shooterId) {
            this.spawnBulletLocal(shooterId);
        }

        // 共通: 弾生成ロジック
        spawnBulletLocal(ownerId) {
            const p = this.state.players[ownerId];
            if (!p || !p.active) return;

            let vx = (ownerId === 'p1') ? BULLET_SPEED : -BULLET_SPEED;
            this.localBullets.push({
                x: p.x, 
                y: p.y, 
                vx: vx, 
                vy: 0, 
                owner: ownerId
            });
        }

        // --- Game Loop ---

        update() {
            const now = Date.now();

            // 1. 自分の移動
            if (this.state.status === "playing") {
                const me = this.state.players[this.myId];
                if (me) {
                    me.x += this.input.x * MOVE_SPEED;
                    me.y += this.input.y * MOVE_SPEED;
                    me.x = Math.max(20, Math.min(CANVAS.width - 20, me.x));
                    me.y = Math.max(20, Math.min(CANVAS.height - 20, me.y));

                    // 発射チェック
                    if (this.input.fire) {
                        this.triggerFire();
                    }
                }
            }

            // 2. 弾の移動と当たり判定 (ローカル計算)
            this.updateBullets();

            // 3. 座標同期
            if (now - this.lastSyncTime > SYNC_INTERVAL) {
                this.syncToFirestore();
                this.lastSyncTime = now;
            }
        }

        updateBullets() {
            // 移動
            this.localBullets.forEach(b => {
                b.x += b.vx;
                b.y += b.vy;
            });

            // 画面外削除
            this.localBullets = this.localBullets.filter(b => 
                b.x > 0 && b.x < CANVAS.width && b.y > 0 && b.y < CANVAS.height
            );

            // 当たり判定 (Visual + Host Logic)
            this.localBullets = this.localBullets.filter(b => {
                let hit = false;
                const targetId = b.owner === 'p1' ? 'p2' : 'p1';
                const target = this.state.players[targetId];

                // ターゲットが生きていれば判定
                if (target.active && target.hp > 0) {
                    const dx = b.x - target.x;
                    const dy = b.y - target.y;
                    
                    if (Math.hypot(dx, dy) < PLAYER_RADIUS + BULLET_RADIUS) {
                        hit = true; // 見た目上消す
                        
                        // ★重要: HPを減らす/死亡判定はHostのみが行う
                        if (this.isHost) {
                            target.hp -= 10;
                            if (target.hp <= 0) {
                                target.hp = 0;
                                this.endGame(b.owner); // 勝者を渡す
                            }
                        }
                    }
                }
                return !hit; // 当たったら消す
            });
        }

        async endGame(winnerId) {
            if (!this.isHost) return;
            if (this.state.status === "finished") return;

            this.state.status = "finished";
            
            await updateDoc(doc(db, "rooms", this.roomId), {
                "status": "finished",
                "winner": winnerId,
                "players.p1.hp": this.state.players.p1.hp,
                "players.p2.hp": this.state.players.p2.hp
            });
        }

        // --- UI & Rendering ---

        switchLayer(name) {
            for (let key in this.layers) {
                if (key === name) this.layers[key].classList.remove('hidden');
                else this.layers[key].classList.add('hidden');
            }
        }

        showResult(winnerId) {
            this.switchLayer('result');
            const title = document.getElementById('result-title');
            const msg = document.getElementById('result-msg');
            
            const amIWinner = (winnerId === this.myId);
            
            if (amIWinner) {
                title.innerText = "YOU WIN!";
                title.className = "win";
                msg.innerText = "Congratulations!";
            } else {
                title.innerText = "YOU LOSE";
                title.className = "lose";
                msg.innerText = "Try again next time.";
            }

            if (this.isHost) {
                document.getElementById('host-controls').classList.remove('hidden');
                document.getElementById('guest-controls').classList.add('hidden');
            } else {
                document.getElementById('host-controls').classList.add('hidden');
                document.getElementById('guest-controls').classList.remove('hidden');
            }
        }

        async restartGame() {
            if (!this.isHost) return;
            
            // リセット
            this.state.players.p1.hp = 100;
            this.state.players.p1.x = 100;
            this.state.players.p2.hp = 100;
            this.state.players.p2.x = CANVAS.width - 100;
            this.state.status = "playing";
            this.localBullets = []; 

            await updateDoc(doc(db, "rooms", this.roomId), {
                "players.p1.hp": 100,
                "players.p1.x": 100,
                "players.p2.hp": 100,
                "players.p2.x": CANVAS.width - 100,
                "status": "playing",
                "winner": null
            });
        }

        async disbandRoom() {
            if (!this.isHost) return;
            try {
                await deleteDoc(doc(db, "rooms", this.roomId));
                location.reload();
            } catch (e) { console.error(e); }
        }

        updateHUD() {
            document.getElementById('text-hp-p1').innerText = this.state.players.p1.hp;
            document.getElementById('bar-hp-p1').style.width = this.state.players.p1.hp + "%";
            document.getElementById('text-hp-p2').innerText = this.state.players.p2.hp;
            document.getElementById('bar-hp-p2').style.width = this.state.players.p2.hp + "%";
        }

        draw() {
            CTX.fillStyle = '#222';
            CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

            // Players
            ['p1', 'p2'].forEach(pid => {
                const p = this.state.players[pid];
                if (!p.active) return;
                
                CTX.beginPath();
                CTX.arc(p.x, p.y, PLAYER_RADIUS, 0, Math.PI*2);
                CTX.fillStyle = pid === 'p1' ? '#00ccff' : '#00ff00';
                CTX.fill();
                CTX.strokeStyle = 'white';
                CTX.lineWidth = 2;
                CTX.stroke();
            });

            // Bullets
            CTX.fillStyle = '#ffeb3b';
            this.localBullets.forEach(b => {
                CTX.beginPath();
                CTX.arc(b.x, b.y, BULLET_RADIUS, 0, Math.PI*2);
                CTX.fill();
            });

            // Stick
            CTX.beginPath();
            CTX.arc(this.stickBase.x, this.stickBase.y, 50, 0, Math.PI*2);
            CTX.strokeStyle = 'rgba(255,255,255,0.3)';
            CTX.lineWidth = 2;
            CTX.stroke();
            CTX.beginPath();
            CTX.arc(this.stickBase.x + this.input.x*50, this.stickBase.y + this.input.y*50, 25, 0, Math.PI*2);
            CTX.fillStyle = 'rgba(255,255,255,0.5)';
            CTX.fill();

            // Fire Button
            const fireX = CANVAS.width - 100;
            const fireY = CANVAS.height - 120;
            CTX.beginPath();
            CTX.arc(fireX, fireY, 40, 0, Math.PI*2);
            CTX.fillStyle = this.input.fire ? 'rgba(255,50,50,0.6)' : 'rgba(255,50,50,0.3)';
            CTX.fill();
            CTX.strokeStyle = 'white';
            CTX.stroke();
            CTX.fillStyle = 'white';
            CTX.font = '14px Arial';
            CTX.textAlign = 'center';
            CTX.fillText("FIRE", fireX, fireY + 5);
        }

        loop(timestamp) {
            this.update();
            this.draw();
            requestAnimationFrame((t) => this.loop(t));
        }

        // --- Inputs ---
        bindButtons() {
            document.getElementById('btn-create').onclick = () => this.createRoom();
            document.getElementById('btn-join').onclick = () => {
                const id = document.getElementById('input-room').value;
                if(id.length === 4) this.joinRoom(id);
                else alert("Enter 4 digits");
            };
            document.getElementById('btn-restart').onclick = () => this.restartGame();
            document.getElementById('btn-close').onclick = () => this.disbandRoom();
            document.getElementById('btn-leave').onclick = () => location.reload();
        }

        setupInputs() {
            const handleTouch = (e) => {
                e.preventDefault();
                const touches = e.changedTouches;
                for (let i = 0; i < touches.length; i++) {
                    const t = touches[i];
                    if (t.clientX < CANVAS.width / 2) {
                        this.touchId = t.identifier;
                        const dx = t.clientX - this.stickBase.x;
                        const dy = t.clientY - this.stickBase.y;
                        const dist = Math.hypot(dx, dy);
                        const max = 50;
                        if (dist > max) { this.input.x = (dx / dist); this.input.y = (dy / dist); }
                        else { this.input.x = dx / max; this.input.y = dy / max; }
                    } else {
                        const dist = Math.hypot(t.clientX - (CANVAS.width - 100), t.clientY - (CANVAS.height - 120));
                        if (dist < 60) this.input.fire = true;
                    }
                }
            };
            const handleEnd = (e) => {
                e.preventDefault();
                const touches = e.changedTouches;
                for (let i = 0; i < touches.length; i++) {
                    const t = touches[i];
                    if (t.identifier === this.touchId) { this.input.x = 0; this.input.y = 0; this.touchId = null; }
                    if (t.clientX > CANVAS.width / 2) this.input.fire = false;
                }
            };
            CANVAS.addEventListener('touchstart', handleTouch, {passive: false});
            CANVAS.addEventListener('touchmove', handleTouch, {passive: false});
            CANVAS.addEventListener('touchend', handleEnd, {passive: false});
        }
    }

    window.onload = () => new Game();
</script>
</body>
</html>
