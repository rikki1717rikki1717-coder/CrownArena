<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Firebase Shooter Debug Mode</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            color: white;
            font-family: monospace; /* ログを見やすく */
            touch-action: none;
            user-select: none;
        }

        canvas {
            display: block;
        }

        /* UIオーバーレイ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10;
            padding-top: 50px;
            box-sizing: border-box;
            overflow-y: auto;
        }

        .panel {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #444;
            max-width: 90%;
            width: 350px;
            margin-bottom: 20px;
        }

        h1 { margin: 0 0 15px 0; font-size: 20px; color: #4dc3ff; }
        
        input {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            background: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 16px;
            text-align: center;
        }

        button {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
        }

        .btn-host { background: #0078d7; color: white; }
        .btn-join { background: #107c10; color: white; }

        .room-code {
            font-size: 28px;
            font-weight: bold;
            color: #ffeb3b;
            letter-spacing: 3px;
            margin: 10px 0;
            background: #000;
            padding: 10px;
            border-radius: 4px;
        }

        /* デバッグログ表示エリア */
        #debug-console {
            width: 90%;
            height: 200px;
            background: #000;
            border: 1px solid #555;
            font-size: 11px;
            color: #0f0;
            padding: 10px;
            overflow-y: scroll;
            text-align: left;
            margin-top: 10px;
            white-space: pre-wrap;
        }

        /* HUD */
        #game-hud {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            font-size: 14px;
            color: #fff;
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="panel" id="panel-menu">
            <h1>Shooter Debug</h1>
            <input type="text" id="input-name" value="Player" placeholder="Name">
            <button class="btn-host" id="btn-create">Create Room (Host)</button>
            <div style="margin: 5px 0; color: #666;">---</div>
            <input type="number" id="input-room-id" placeholder="Room ID">
            <button class="btn-join" id="btn-join">Join Room</button>
        </div>

        <div class="panel" id="panel-waiting" style="display: none;">
            <h1>Waiting...</h1>
            <div class="room-code" id="display-room-id">----</div>
            <div id="waiting-status" style="color:#aaa; font-size:12px;">Initializing...</div>
        </div>

        <div id="debug-console">System Ready...</div>
    </div>

    <div id="game-hud">
        STATUS: <span id="connection-status" style="color:yellow;">Disconnected</span>
    </div>

    <canvas id="gameCanvas"></canvas>

<script type="module">
    // ---------------------------------------------------------
    // 1. Firebase Config & Init
    // ---------------------------------------------------------
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { 
        getFirestore, collection, doc, setDoc, getDoc, updateDoc, 
        onSnapshot, addDoc 
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    const firebaseConfig = {
        apiKey: "AIzaSyA8B-JtwDskK3omhjUCbjERHBZ6UDdm854",
        authDomain: "crownarena-1a321.firebaseapp.com",
        projectId: "crownarena-1a321",
        storageBucket: "crownarena-1a321.firebasestorage.app",
        messagingSenderId: "103440875843",
        appId: "1:103440875843:web:d34b314c4df7e0d491aff6",
        measurementId: "G-N9KDL9B9Y5"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // ログヘルパー
    const logConsole = document.getElementById('debug-console');
    function log(msg) {
        const time = new Date().toLocaleTimeString();
        const line = `[${time}] ${msg}`;
        console.log(line);
        logConsole.textContent = line + "\n" + logConsole.textContent;
    }
    log("Firebase Initialized.");

    // ---------------------------------------------------------
    // 2. Network Manager (Strict Debugging)
    // ---------------------------------------------------------
    class NetworkManager {
        constructor() {
            this.pc = null;
            this.dc = null;
            this.roomId = null;
            this.isHost = false;
            this.unsubscribe = null; // onSnapshot解除用

            // 待機キュー
            this.remoteCandidatesQueue = [];

            this.rtcConfig = {
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            };

            // コールバック
            this.onConnect = () => {};
            this.onData = (data) => {};
            this.onStatus = (msg) => {};
        }

        reset() {
            if (this.pc) this.pc.close();
            if (this.unsubscribe) this.unsubscribe();
            this.pc = null;
            this.dc = null;
            this.remoteCandidatesQueue = [];
        }

        createPeerConnection() {
            log("Creating RTCPeerConnection...");
            this.pc = new RTCPeerConnection(this.rtcConfig);

            this.pc.onconnectionstatechange = () => {
                log(`WebRTC State: ${this.pc.connectionState}`);
                if (this.pc.connectionState === 'connected') {
                    this.onStatus("Connected!");
                }
            };
            
            this.pc.oniceconnectionstatechange = () => {
                log(`ICE State: ${this.pc.iceConnectionState}`);
            };
        }

        setupDataChannel(channel) {
            this.dc = channel;
            this.dc.onopen = () => {
                log(">>> DataChannel OPEN! <<<");
                this.onConnect();
            };
            this.dc.onmessage = (e) => {
                try {
                    const data = JSON.parse(e.data);
                    this.onData(data);
                } catch(err) {
                    console.error(err);
                }
            };
        }

        send(data) {
            if (this.dc && this.dc.readyState === 'open') {
                this.dc.send(JSON.stringify(data));
            }
        }

        // ICE Candidate 収集・保存・監視
        async collectIceCandidates(roomRef, localName, remoteName) {
            const localCol = collection(roomRef, localName);
            const remoteCol = collection(roomRef, remoteName);

            // ローカル候補が出たら保存
            this.pc.onicecandidate = async (event) => {
                if (event.candidate) {
                    try {
                        await addDoc(localCol, event.candidate.toJSON());
                        log(`Sent ICE candidate to ${localName}`);
                    } catch (e) {
                        log(`Error sending ICE: ${e.message}`);
                    }
                }
            };

            // 相手の候補を監視
            onSnapshot(remoteCol, (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === 'added') {
                        const candidate = new RTCIceCandidate(change.doc.data());
                        log(`Received ICE candidate from ${remoteName}`);
                        
                        if (!this.pc.remoteDescription) {
                            log("Queueing ICE (RemoteDescription not set)");
                            this.remoteCandidatesQueue.push(candidate);
                        } else {
                            await this.pc.addIceCandidate(candidate);
                        }
                    }
                });
            });
        }

        async processQueue() {
            if (this.remoteCandidatesQueue.length > 0) {
                log(`Processing ${this.remoteCandidatesQueue.length} queued ICE candidates`);
                for (const candidate of this.remoteCandidatesQueue) {
                    await this.pc.addIceCandidate(candidate);
                }
                this.remoteCandidatesQueue = [];
            }
        }

        // --- HOST Logic ---
        async createRoom() {
            this.isHost = true;
            this.reset();
            this.createPeerConnection();

            // DataChannel作成
            const channel = this.pc.createDataChannel("game");
            this.setupDataChannel(channel);

            // Room ID
            this.roomId = Math.floor(1000 + Math.random() * 9000).toString();
            log(`Generated Room ID: ${this.roomId}`);
            
            const roomRef = doc(db, 'rooms', this.roomId);

            // Offer作成
            log("Creating Offer...");
            const offer = await this.pc.createOffer();
            await this.pc.setLocalDescription(offer);

            // Firestore初期データ
            // ユーザー指定の players 構造を明確にする
            const roomData = {
                offer: { type: offer.type, sdp: offer.sdp },
                players: {
                    host: { x: 100, y: 100, active: true },
                    guest: null // まだいない
                },
                createdAt: new Date().toISOString()
            };

            try {
                await setDoc(roomRef, roomData);
                log("Room document created in Firestore.");
            } catch (e) {
                log(`Error creating room doc: ${e.message}`);
                throw e;
            }

            // ICE処理開始
            this.collectIceCandidates(roomRef, 'callerCandidates', 'calleeCandidates');

            // 監視開始 (onSnapshot)
            log("Start listening for Joiner...");
            this.unsubscribe = onSnapshot(roomRef, async (snapshot) => {
                log("onSnapshot fired on Room Doc");
                const data = snapshot.data();
                if (!data) return;

                // ゲスト参加検知
                if (data.players && data.players.guest && !this.guestJoinedLog) {
                    log("Guest joined! (players.guest updated)");
                    this.guestJoinedLog = true; // ログ重複防止
                }

                // Answer検知
                if (!this.pc.currentRemoteDescription && data.answer) {
                    log("Answer received! Setting Remote Description...");
                    const answer = new RTCSessionDescription(data.answer);
                    await this.pc.setRemoteDescription(answer);
                    await this.processQueue();
                    log("Remote Description Set. Connection should start.");
                }
            });

            return this.roomId;
        }

        // --- JOIN Logic ---
        async joinRoom(roomId) {
            this.isHost = false;
            this.roomId = roomId;
            this.reset();
            
            log(`Joining Room: ${roomId}...`);
            const roomRef = doc(db, 'rooms', roomId);

            try {
                const roomSnapshot = await getDoc(roomRef);
                if (!roomSnapshot.exists()) {
                    throw new Error("Room does not exist!");
                }
                log("Room found.");

                this.createPeerConnection();

                // DataChannel受信待機
                this.pc.ondatachannel = (e) => {
                    log("DataChannel received from Host.");
                    this.setupDataChannel(e.channel);
                };

                // Guest情報書き込み (Hostに通知)
                log("Registering as Guest...");
                await updateDoc(roomRef, {
                    "players.guest": { x: 300, y: 100, active: true }
                });

                // Offerセット
                const data = roomSnapshot.data();
                if (data.offer) {
                    log("Setting Remote Description (Offer)...");
                    await this.pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                } else {
                    throw new Error("No Offer in room!");
                }

                // Answer作成
                log("Creating Answer...");
                const answer = await this.pc.createAnswer();
                await this.pc.setLocalDescription(answer);

                // Answer保存
                log("Sending Answer...");
                await updateDoc(roomRef, {
                    answer: { type: answer.type, sdp: answer.sdp }
                });

                // ICE開始
                this.collectIceCandidates(roomRef, 'calleeCandidates', 'callerCandidates');
                log("Join process completed. Waiting for connection...");

            } catch (e) {
                log(`Join Error: ${e.message}`);
                throw e;
            }
        }
    }

    // ---------------------------------------------------------
    // 3. Game & UI Logic
    // ---------------------------------------------------------
    class Game {
        constructor() {
            this.canvas = document.getElementById('gameCanvas');
            this.ctx = this.canvas.getContext('2d');
            this.resize();

            this.network = new NetworkManager();
            
            // プレイヤーデータ
            this.localPlayer = { x: 100, y: 100, color: '#00ccff', id: 1 };
            this.remotePlayer = { x: 300, y: 100, color: '#00ff00', id: 2 };
            
            this.input = { x: 0, y: 0 };
            this.stickBase = { x: 100, y: 0 };
            this.touchId = null;

            // UI
            this.uiLayer = document.getElementById('ui-layer');
            this.panelMenu = document.getElementById('panel-menu');
            this.panelWaiting = document.getElementById('panel-waiting');
            this.hudStatus = document.getElementById('connection-status');
            this.displayRoomId = document.getElementById('display-room-id');
            this.waitingStatus = document.getElementById('waiting-status');

            window.addEventListener('resize', () => this.resize());
            this.setupUI();
            this.setupTouch();

            // ループ開始
            requestAnimationFrame((t) => this.loop(t));
        }

        resize() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            this.stickBase = { x: 120, y: this.canvas.height - 120 };
        }

        setupUI() {
            // イベントバインド
            this.network.onConnect = () => {
                log("Game Connected! Hiding UI.");
                this.hudStatus.innerText = "CONNECTED";
                this.hudStatus.style.color = "#00ff00";
                
                // UI非表示アニメーション
                this.uiLayer.style.transition = "opacity 0.5s";
                this.uiLayer.style.opacity = "0";
                setTimeout(() => { this.uiLayer.style.display = "none"; }, 500);
            };

            this.network.onStatus = (msg) => {
                this.waitingStatus.innerText = msg;
            };

            this.network.onData = (data) => {
                if (data.type === 'move') {
                    this.remotePlayer.x = data.x;
                    this.remotePlayer.y = data.y;
                }
            };

            // ボタン動作
            document.getElementById('btn-create').onclick = async () => {
                try {
                    const roomId = await this.network.createRoom();
                    this.localPlayer.id = 1; this.localPlayer.color = '#00ccff';
                    this.displayRoomId.innerText = roomId;
                    this.panelMenu.style.display = 'none';
                    this.panelWaiting.style.display = 'block';
                    this.waitingStatus.innerText = "Waiting for player...";
                } catch (e) {
                    alert("Create Failed: " + e);
                }
            };

            document.getElementById('btn-join').onclick = async () => {
                const id = document.getElementById('input-room-id').value;
                if (!id || id.length !== 4) return alert("Invalid Room ID");
                
                try {
                    this.localPlayer.id = 2; this.localPlayer.color = '#00ff00';
                    this.waitingStatus.innerText = "Connecting...";
                    this.panelMenu.style.display = 'none';
                    this.panelWaiting.style.display = 'block';
                    this.displayRoomId.innerText = id;
                    
                    await this.network.joinRoom(id);
                } catch (e) {
                    alert("Join Failed: " + e);
                    this.panelMenu.style.display = 'block';
                    this.panelWaiting.style.display = 'none';
                }
            };
        }

        setupTouch() {
            const getTouch = (e) => {
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].clientX < this.canvas.width/2) return e.changedTouches[i];
                }
                return null;
            };

            this.canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const t = getTouch(e);
                if (t && this.touchId === null) {
                    this.touchId = t.identifier;
                    this.updateInput(t.clientX, t.clientY);
                }
            }, {passive:false});

            this.canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === this.touchId) {
                        this.updateInput(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                    }
                }
            }, {passive:false});

            this.canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === this.touchId) {
                        this.touchId = null;
                        this.input = {x:0, y:0};
                    }
                }
            }, {passive:false});
        }

        updateInput(tx, ty) {
            const max = 50;
            let dx = tx - this.stickBase.x;
            let dy = ty - this.stickBase.y;
            const dist = Math.hypot(dx, dy);
            if (dist > max) { dx = (dx/dist)*max; dy = (dy/dist)*max; }
            this.input.x = dx/max;
            this.input.y = dy/max;
        }

        update() {
            // 移動
            const speed = 5;
            this.localPlayer.x += this.input.x * speed;
            this.localPlayer.y += this.input.y * speed;
            
            // 制限
            const r = 20;
            this.localPlayer.x = Math.max(r, Math.min(this.canvas.width-r, this.localPlayer.x));
            this.localPlayer.y = Math.max(r, Math.min(this.canvas.height-r, this.localPlayer.y));

            // 送信
            this.network.send({
                type: 'move',
                x: this.localPlayer.x,
                y: this.localPlayer.y
            });
        }

        draw() {
            this.ctx.fillStyle = '#1a1a1a';
            this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);

            const drawP = (p) => {
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, 20, 0, Math.PI*2);
                this.ctx.fillStyle = p.color;
                this.ctx.fill();
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
            };

            drawP(this.localPlayer);
            drawP(this.remotePlayer);

            // Stick
            this.ctx.beginPath();
            this.ctx.arc(this.stickBase.x, this.stickBase.y, 50, 0, Math.PI*2);
            this.ctx.fillStyle = 'rgba(255,255,255,0.1)';
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.arc(this.stickBase.x + this.input.x*50, this.stickBase.y + this.input.y*50, 25, 0, Math.PI*2);
            this.ctx.fillStyle = 'rgba(255,255,255,0.5)';
            this.ctx.fill();
        }

        loop() {
            this.update();
            this.draw();
            requestAnimationFrame(() => this.loop());
        }
    }

    // Start
    window.onload = () => new Game();

</script>
</body>
</html>
