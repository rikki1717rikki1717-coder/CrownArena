<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Crown Arena v2.2</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            color: white;
            font-family: 'Segoe UI', monospace;
            touch-action: none;
            user-select: none;
        }

        canvas {
            display: block;
        }

        /* --- UI Layers --- */
        .layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.9);
            z-index: 20;
            transition: opacity 0.3s;
            pointer-events: auto;
        }

        .panel {
            background: #2a2a2a;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid #444;
            width: 320px;
            max-width: 90%;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }

        h1 { margin: 0 0 20px 0; color: #ffd700; font-size: 28px; text-shadow: 0 0 10px #ff8c00; }
        h2 { margin: 0 0 15px 0; font-size: 36px; font-weight: bold; }

        input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 6px;
            font-size: 16px;
            text-align: center;
        }

        button {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            color: white;
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.98); }

        .btn-host { background: #0078d7; }
        .btn-join { background: #107c10; }
        .btn-restart { background: #e6c200; color: black; }
        .btn-close { background: #d32f2f; }

        .win { color: #00ff00; }
        .lose { color: #ff0000; }
        .draw { color: #aaaaaa; }

        /* --- HUD --- */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* Timer */
        #timer-container {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 5px #000;
        }
        
        /* HP Bars */
        .player-info {
            position: absolute;
            top: 10px;
            font-size: 14px;
            text-shadow: 1px 1px 2px black;
        }
        .p1-info { left: 10px; }
        .p2-info { right: 10px; text-align: right; }

        .hp-bar-bg {
            width: 120px;
            height: 10px;
            background: #333;
            border: 1px solid #777;
            margin-top: 5px;
        }
        .hp-fill {
            height: 100%;
            background: #0f0;
            width: 100%;
            transition: width 0.2s, background-color 0.2s;
        }

        /* Ammo UI */
        #ammo-wrapper {
            position: absolute;
            bottom: 130px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        #ammo-container {
            display: flex;
            gap: 5px;
        }
        .ammo-slot {
            width: 30px;
            height: 10px;
            background: #333;
            border: 1px solid #777;
            transform: skewX(-20deg);
        }
        .ammo-active {
            background: #ff9800;
            box-shadow: 0 0 5px #ff9800;
        }
        #reload-bar-bg {
            width: 100px;
            height: 4px;
            background: #222;
            border: 1px solid #555;
        }
        #reload-bar-fill {
            height: 100%;
            background: #ff9800;
            width: 0%;
            transition: width 0.1s linear;
        }

        /* ULT UI */
        #ult-container {
            position: absolute;
            top: 60px;
            right: 10px;
            width: 60px;
            text-align: center;
            pointer-events: auto;
        }
        .ult-gauge-bg {
            width: 100%;
            height: 8px;
            background: #333;
            border: 1px solid #aaa;
            margin-bottom: 5px;
        }
        .ult-fill {
            height: 100%;
            background: #d000ff;
            width: 0%;
            transition: width 0.2s;
        }
        #btn-ult {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #444;
            color: #888;
            font-weight: bold;
            font-size: 14px;
            border: 2px solid #666;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: default;
            transition: all 0.2s;
        }
        #btn-ult.ready {
            background: #9c27b0;
            color: white;
            border-color: #fff;
            box-shadow: 0 0 15px #d000ff;
            cursor: pointer;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        #room-id-display {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.5);
            font-size: 12px;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="layer-menu" class="layer">
        <div class="panel">
            <h1>Crown Arena v2.2</h1>
            <input type="text" id="input-name" placeholder="Your Name" style="margin-bottom: 15px;">
            <button class="btn-host" id="btn-create">Create Room (Host)</button>
            <div style="margin: 10px 0; color:#666;">- OR -</div>
            <input type="number" id="input-room" placeholder="4-Digit Room ID">
            <button class="btn-join" id="btn-join">Join Room</button>
            <div id="status-msg" style="margin-top:10px; color:#aaa; font-size:12px;">Ready</div>
        </div>
    </div>

    <div id="layer-wait" class="layer hidden">
        <div class="panel">
            <h1>Waiting for Player...</h1>
            <div>Room ID</div>
            <div id="display-room-code" style="font-size:32px; color:#ffeb3b; font-weight:bold; margin:10px 0;">----</div>
            <div style="font-size: 12px; color: #aaa;">Share this ID</div>
        </div>
    </div>

    <div id="layer-result" class="layer hidden">
        <div class="panel">
            <h2 id="result-title">RESULT</h2>
            <div id="result-msg" style="margin-bottom:20px;"></div>
            
            <div id="host-controls" class="hidden">
                <button class="btn-restart" id="btn-restart">Play Again</button>
                <button class="btn-close" id="btn-close">Disband Room</button>
            </div>
            
            <div id="guest-controls" class="hidden">
                <div style="color:#aaa; margin-bottom:10px;">Waiting for Host...</div>
                <button class="btn-close" id="btn-leave">Leave Room</button>
            </div>
        </div>
    </div>

    <div id="hud" class="hidden">
        <div id="timer-container">60</div>

        <div class="player-info p1-info">
            P1 (Blue)
            <div class="hp-bar-bg"><div id="bar-hp-p1" class="hp-fill"></div></div>
        </div>
        
        <div class="player-info p2-info">
            P2 (Green)
            <div class="hp-bar-bg"><div id="bar-hp-p2" class="hp-fill"></div></div>
        </div>

        <div id="ammo-wrapper">
            <div id="ammo-container">
                <div class="ammo-slot ammo-active" id="ammo-1"></div>
                <div class="ammo-slot ammo-active" id="ammo-2"></div>
                <div class="ammo-slot ammo-active" id="ammo-3"></div>
            </div>
            <div id="reload-bar-bg"><div id="reload-bar-fill"></div></div>
        </div>

        <div id="ult-container">
            <div class="ult-gauge-bg"><div id="bar-ult" class="ult-fill"></div></div>
            <div id="btn-ult">ULT</div>
        </div>

        <div id="room-id-display">Room: ----</div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { 
        getFirestore, doc, setDoc, updateDoc, onSnapshot, getDoc, deleteDoc, increment 
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    const firebaseConfig = {
        apiKey: "AIzaSyA8B-JtwDskK3omhjUCbjERHBZ6UDdm854",
        authDomain: "crownarena-1a321.firebaseapp.com",
        projectId: "crownarena-1a321",
        storageBucket: "crownarena-1a321.firebasestorage.app",
        messagingSenderId: "103440875843",
        appId: "1:103440875843:web:d34b314c4df7e0d491aff6",
        measurementId: "G-N9KDL9B9Y5"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // --- Config ---
    const PLAYER_RADIUS = 20;
    const BULLET_RADIUS = 6;
    const ULT_RADIUS = 20;
    const MOVE_SPEED = 5;
    const BULLET_SPEED = 15;
    const KNOCKBACK_FORCE = 10;
    
    const AMMO_MAX = 3;
    const AMMO_RELOAD_TIME = 1500;
    const FIRE_RATE = 200; 
    const SYNC_INTERVAL = 50; 
    
    const GAME_DURATION = 60; 
    const ULT_MAX = 100;
    const ULT_CHARGE_PASSIVE = 5; 
    const ULT_CHARGE_HIT = 10;

    class Game {
        constructor() {
            this.roomId = null;
            this.isHost = false; 
            this.myId = null; 
            
            this.state = {
                players: {
                    p1: { x: 100, y: 100, hp: 100, active: false, ult: 0, slowUntil: 0, name: "Blue" },
                    p2: { x: 300, y: 100, hp: 100, active: false, ult: 0, slowUntil: 0, name: "Green" }
                },
                status: "waiting",
                remainingTime: GAME_DURATION,
                startTime: null,
                bulletSeq: 0,
                ultSeq: 0
            };

            this.localBullets = []; 
            this.particles = [];

            // Local Game State
            this.myAmmo = AMMO_MAX;
            this.ammoTimer = 0;
            this.lastFireTime = 0;
            this.ultLocked = false; // ULT連射防止フラグ

            // Audio
            this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            // Input
            this.input = {
                move: { active: false, x: 0, y: 0, id: null, angle: 0 },
                aim:  { active: false, x: 0, y: 0, id: null, angle: 0 },
            };
            
            // Stick Positions
            this.stickLeftBase = { x: 0, y: 0 };
            this.stickRightBase = { x: 0, y: 0 };
            this.stickRadius = 60;

            this.lastSyncTime = 0;
            this.lastTimeTick = 0;
            this.lastFrameTime = Date.now();
            this.unsubscribe = null;
            this.isRoomReady = false;

            this.canvas = document.getElementById('gameCanvas');
            this.ctx = this.canvas.getContext('2d');

            this.resize();
            window.addEventListener('resize', () => this.resize());
            this.setupInputs();
            
            this.layers = {
                menu: document.getElementById('layer-menu'),
                wait: document.getElementById('layer-wait'),
                result: document.getElementById('layer-result')
            };
            this.hud = document.getElementById('hud');
            
            this.bindButtons();

            requestAnimationFrame((t) => this.loop(t));
        }

        resize() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            this.stickLeftBase = { x: 120, y: this.canvas.height - 120 };
            this.stickRightBase = { x: this.canvas.width - 120, y: this.canvas.height - 120 };
        }

        // --- Audio ---
        initAudio() {
            if (this.audioCtx.state === 'suspended') {
                this.audioCtx.resume();
            }
        }

        playShootSound() {
            if (!this.audioCtx) return;
            const osc = this.audioCtx.createOscillator();
            const gain = this.audioCtx.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(400, this.audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, this.audioCtx.currentTime + 0.05);
            gain.gain.setValueAtTime(0.1, this.audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.audioCtx.currentTime + 0.05);
            osc.connect(gain);
            gain.connect(this.audioCtx.destination);
            osc.start();
            osc.stop(this.audioCtx.currentTime + 0.05);
        }

        playUltSound() {
            if (!this.audioCtx) return;
            const osc = this.audioCtx.createOscillator();
            const gain = this.audioCtx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(200, this.audioCtx.currentTime);
            osc.frequency.linearRampToValueAtTime(800, this.audioCtx.currentTime + 0.3);
            gain.gain.setValueAtTime(0.2, this.audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, this.audioCtx.currentTime + 0.3);
            osc.connect(gain);
            gain.connect(this.audioCtx.destination);
            osc.start();
            osc.stop(this.audioCtx.currentTime + 0.3);
        }

        playHitSound() {
            if (!this.audioCtx) return;
            const osc = this.audioCtx.createOscillator();
            const gain = this.audioCtx.createGain();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(150, this.audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(50, this.audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.2, this.audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.audioCtx.currentTime + 0.1);
            osc.connect(gain);
            gain.connect(this.audioCtx.destination);
            osc.start();
            osc.stop(this.audioCtx.currentTime + 0.1);
        }

        // --- Network ---

        resetLocalState() {
            this.state.players.p1.x = 100;
            this.state.players.p1.y = 100;
            this.state.players.p1.hp = 100;
            this.state.players.p1.ult = 0;
            this.state.players.p1.active = true;

            this.state.players.p2.x = this.canvas.width - 100;
            this.state.players.p2.y = 100;
            this.state.players.p2.hp = 100;
            this.state.players.p2.ult = 0;
            this.state.players.p2.active = false;

            this.myAmmo = AMMO_MAX;
            this.localBullets = [];
            this.ultLocked = false;
        }

        async createRoom() {
            this.initAudio();
            this.roomId = Math.floor(1000 + Math.random() * 9000).toString();
            this.isHost = true;
            this.myId = 'p1';
            this.resetLocalState();

            const nameInput = document.getElementById("input-name");
            const myName = nameInput.value.trim() || "Blue";
            this.state.players.p1.name = myName;
            this.state.players.p1.active = true;

            const initialData = {
                players: {
                    p1: this.state.players.p1,
                    p2: { ...this.state.players.p2, name: "Green", active: false } 
                },
                status: "waiting",
                startTime: null,
                winner: null,
                bulletSeq: 0,
                ultSeq: 0,
                lastShooter: null,
                lastAngle: 0
            };

            try {
                await setDoc(doc(db, "rooms", this.roomId), initialData);
                this.isRoomReady = true;
                this.switchLayer('wait');
                document.getElementById('display-room-code').innerText = this.roomId;
                document.getElementById('room-id-display').innerText = "Room: " + this.roomId;
                this.subscribeToRoom();
            } catch (e) {
                console.error(e);
                alert("Error creating room.");
            }
        }

        async joinRoom(id) {
            this.initAudio();
            const docRef = doc(db, "rooms", id);
            try {
                const snap = await getDoc(docRef);
                if (!snap.exists()) { alert("Room not found!"); return; }
                if (snap.data().status === "closed") { alert("Room is closed."); return; }

                this.roomId = id;
                this.isHost = false;
                this.myId = 'p2';
                this.resetLocalState(); 

                const nameInput = document.getElementById("input-name");
                const myName = nameInput.value.trim() || "Green";
                this.state.players.p2.name = myName;
                this.state.players.p2.active = true;

                await updateDoc(docRef, {
                    "players.p2.active": true,
                    "players.p2.x": this.state.players.p2.x,
                    "players.p2.name": myName
                });

                document.getElementById('room-id-display').innerText = "Room: " + this.roomId;
                this.isRoomReady = true;
                this.subscribeToRoom();

            } catch (e) {
                console.error(e);
                alert("Error joining room.");
            }
        }

        subscribeToRoom() {
            if (this.unsubscribe) this.unsubscribe();
            
            this.unsubscribe = onSnapshot(doc(db, "rooms", this.roomId), (docSnap) => {
                if (!docSnap.exists()) {
                    console.warn("Doc missing");
                    return;
                }
                const data = docSnap.data();
                
                if (data.status === "closed") {
                    alert("Room closed.");
                    location.reload();
                    return;
                }

                if (this.isHost && this.state.status === "waiting" && data.players.p2?.active) {
                    this.startGameAsHost();
                }

                if (data.status === "playing") {
                    this.switchLayer(null); 
                    this.state.status = "playing";
                    this.hud.classList.remove('hidden');
                } else if (data.status === "finished") {
                    this.state.status = "finished";
                    this.hud.classList.add('hidden');
                    this.showResult(data.winner);
                }

                if (data.startTime) this.state.startTime = data.startTime;

                if (data.bulletSeq > this.state.bulletSeq) {
                    if (data.lastShooter !== this.myId) {
                        this.spawnBulletFromSync(data.lastShooter, false, data.lastAngle);
                    }
                    this.state.bulletSeq = data.bulletSeq;
                }
                if (data.ultSeq > this.state.ultSeq) {
                    if (data.lastShooter !== this.myId) {
                        this.spawnBulletFromSync(data.lastShooter, true, data.lastAngle);
                    }
                    this.state.ultSeq = data.ultSeq;
                }

                if (this.isHost) {
                    if (data.players.p2) {
                        const p2 = this.state.players.p2;
                        p2.x = data.players.p2.x;
                        p2.y = data.players.p2.y;
                        p2.active = data.players.p2.active;
                        if(data.players.p2.name) p2.name = data.players.p2.name;
                    }
                } else {
                    if (data.players.p1) Object.assign(this.state.players.p1, data.players.p1);
                    if (data.players.p2) {
                        const p2 = this.state.players.p2;
                        p2.hp = data.players.p2.hp;
                        p2.ult = data.players.p2.ult;
                        p2.slowUntil = data.players.p2.slowUntil;
                        p2.active = data.players.p2.active;
                        if(data.players.p2.name) p2.name = data.players.p2.name;
                    }
                }
                this.updateUI();
            });
        }

        async startGameAsHost() {
            const now = Date.now();
            this.state.startTime = now;
            try {
                await updateDoc(doc(db, "rooms", this.roomId), {
                    startTime: now,
                    status: "playing"
                });
            } catch(e) {}
        }

        async syncToFirestore() {
            if (!this.roomId || this.state.status === "finished") return;
            const ref = doc(db, "rooms", this.roomId);
            const me = this.state.players[this.myId];

            if (isNaN(me.x) || isNaN(me.y)) return;

            try {
                if (this.isHost) {
                    await updateDoc(ref, {
                        "remainingTime": Math.ceil(this.state.remainingTime),
                        "players.p1.x": me.x,
                        "players.p1.y": me.y,
                        "players.p1.hp": this.state.players.p1.hp,
                        "players.p1.ult": Math.floor(this.state.players.p1.ult),
                        "players.p1.slowUntil": this.state.players.p1.slowUntil,
                        "players.p2.hp": this.state.players.p2.hp,
                        "players.p2.ult": Math.floor(this.state.players.p2.ult),
                        "players.p2.slowUntil": this.state.players.p2.slowUntil
                    });
                } else {
                    await updateDoc(ref, {
                        "players.p2.x": me.x,
                        "players.p2.y": me.y
                    });
                }
            } catch (e) {}
        }

        // --- Logic ---

        tryFire(angle) {
            if (this.myAmmo <= 0) return;
            const now = Date.now();
            if (now - this.lastFireTime < FIRE_RATE) return;

            this.lastFireTime = now;
            this.myAmmo--; 

            this.spawnBulletLocal(this.myId, false, angle);
            this.sendFireEvent(false, angle);
        }

        triggerUlt() {
            if (this.ultLocked) return;
            const me = this.state.players[this.myId];
            if (me.ult < ULT_MAX) return;

            this.ultLocked = true;
            me.ult = 0; // Local immediate update
            
            const targetId = (this.myId === 'p1') ? 'p2' : 'p1';
            const target = this.state.players[targetId];
            let angle = 0;
            if (target && target.active) {
                angle = Math.atan2(target.y - me.y, target.x - me.x);
            } else {
                angle = (this.myId === 'p1') ? 0 : Math.PI;
            }

            this.spawnBulletLocal(this.myId, true, angle);
            this.sendFireEvent(true, angle);

            // Cooldown lock
            setTimeout(() => { this.ultLocked = false; }, 500);
        }

        async sendFireEvent(isUlt, angle) {
            const ref = doc(db, "rooms", this.roomId);
            try {
                if (isUlt) {
                    await updateDoc(ref, { 
                        ultSeq: increment(1), 
                        lastShooter: this.myId, 
                        lastAngle: angle,
                        [`players.${this.myId}.ult`]: 0
                    });
                } else {
                    await updateDoc(ref, { bulletSeq: increment(1), lastShooter: this.myId, lastAngle: angle });
                }
            } catch(e) {}
        }

        spawnBulletFromSync(shooterId, isUlt, angle) {
            this.spawnBulletLocal(shooterId, isUlt, angle);
        }

        spawnBulletLocal(ownerId, isUlt, angle) {
            const p = this.state.players[ownerId];
            if (!p || !p.active) return;

            if (isNaN(p.x) || isNaN(p.y)) return;

            this.localBullets.push({
                x: p.x, 
                y: p.y, 
                vx: Math.cos(angle) * BULLET_SPEED, 
                vy: Math.sin(angle) * BULLET_SPEED, 
                angle: angle,
                owner: ownerId, 
                isUlt: isUlt, 
                r: isUlt ? ULT_RADIUS : BULLET_RADIUS
            });

            // Effect
            for(let i=0; i<5; i++){
                this.particles.push({
                    x: p.x + Math.cos(angle)*20, 
                    y: p.y + Math.sin(angle)*20,
                    vx: (Math.random()-0.5)*5,
                    vy: (Math.random()-0.5)*5,
                    life: 10,
                    color: isUlt ? '#d000ff' : '#ffaa00'
                });
            }

            // Sound
            if (isUlt) this.playUltSound();
            else this.playShootSound();
        }

        // --- Loop ---

        update(dt) {
            const now = Date.now();
            const deltaTimeSec = (now - this.lastFrameTime) / 1000;
            this.lastFrameTime = now;

            if (this.state.status === "playing" && this.state.startTime) {
                const elapsed = (now - this.state.startTime) / 1000;
                this.state.remainingTime = Math.max(0, GAME_DURATION - elapsed);
                if (this.isHost && this.state.remainingTime <= 0) {
                    this.checkTimeOver();
                }
            }

            if (this.state.status === "playing") {
                // Reload
                if (this.myAmmo < AMMO_MAX) {
                    this.ammoTimer += (deltaTimeSec * 1000);
                    if (this.ammoTimer >= AMMO_RELOAD_TIME) {
                        this.myAmmo++;
                        this.ammoTimer = 0;
                    }
                } else {
                    this.ammoTimer = 0;
                }

                if (this.isHost) {
                    ['p1', 'p2'].forEach(pid => {
                        const p = this.state.players[pid];
                        if (p.active && p.ult < ULT_MAX) {
                            p.ult += ULT_CHARGE_PASSIVE * deltaTimeSec;
                            if (p.ult > ULT_MAX) p.ult = ULT_MAX;
                        }
                    });
                }

                const me = this.state.players[this.myId];
                if (me) {
                    let speed = MOVE_SPEED;
                    if (now < me.slowUntil) speed *= 0.5;

                    if (this.input.move.active) {
                        const mx = Math.cos(this.input.move.angle);
                        const my = Math.sin(this.input.move.angle);
                        me.x += mx * speed;
                        me.y += my * speed;
                    }

                    if (isNaN(me.x)) me.x = 100;
                    if (isNaN(me.y)) me.y = 100;

                    me.x = Math.max(20, Math.min(this.canvas.width - 20, me.x));
                    me.y = Math.max(20, Math.min(this.canvas.height - 20, me.y));
                }
            }

            this.updateBullets();
            this.updateParticles();

            if (now - this.lastSyncTime > SYNC_INTERVAL) {
                this.syncToFirestore();
                this.lastSyncTime = now;
            }
        }

        updateBullets() {
            this.localBullets.forEach(b => {
                b.x += b.vx;
                b.y += b.vy;
            });

            this.localBullets = this.localBullets.filter(b => 
                b.x > 0 && b.x < this.canvas.width && b.y > 0 && b.y < this.canvas.height
            );

            this.localBullets = this.localBullets.filter(b => {
                let hit = false;
                const targetId = b.owner === 'p1' ? 'p2' : 'p1';
                const target = this.state.players[targetId];

                if (target.active && target.hp > 0) {
                    const dx = b.x - target.x;
                    const dy = b.y - target.y;
                    
                    if (Math.hypot(dx, dy) < PLAYER_RADIUS + b.r) {
                        hit = true; 
                        this.playHitSound();
                        
                        if (this.isHost) {
                            const dmg = b.isUlt ? 20 : 10;
                            target.hp -= dmg;
                            target.ult = Math.min(ULT_MAX, target.ult + ULT_CHARGE_HIT);
                            if (b.isUlt) target.slowUntil = Date.now() + 3000;

                            const knockDist = KNOCKBACK_FORCE;
                            target.x += Math.cos(b.angle) * knockDist;
                            target.y += Math.sin(b.angle) * knockDist;
                            target.x = Math.max(20, Math.min(this.canvas.width - 20, target.x));
                            target.y = Math.max(20, Math.min(this.canvas.height - 20, target.y));

                            if (target.hp <= 0) {
                                target.hp = 0;
                                this.endGame(b.owner);
                            }
                        }
                    }
                }
                return !hit; 
            });
        }

        updateParticles() {
            this.particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
            });
            this.particles = this.particles.filter(p => p.life > 0);
        }

        checkTimeOver() {
            const p1 = this.state.players.p1.hp;
            const p2 = this.state.players.p2.hp;
            let winner = null;
            if (p1 > p2) winner = 'p1';
            else if (p2 > p1) winner = 'p2';
            else winner = 'draw';
            this.endGame(winner);
        }

        async endGame(winnerId) {
            if (!this.isHost || this.state.status === "finished") return;
            this.state.status = "finished";
            
            await updateDoc(doc(db, "rooms", this.roomId), {
                "status": "finished",
                "winner": winnerId,
                "remainingTime": 0,
                "players.p1.hp": this.state.players.p1.hp,
                "players.p2.hp": this.state.players.p2.hp
            });
        }

        // --- UI ---

        switchLayer(name) {
            for (let key in this.layers) {
                if (key === name) this.layers[key].classList.remove('hidden');
                else this.layers[key].classList.add('hidden');
            }
        }

        updateUI() {
            const timerEl = document.getElementById('timer-container');
            if (timerEl) {
                timerEl.innerText = Math.max(0, Math.ceil(this.state.remainingTime));
            }

            const p1 = this.state.players.p1;
            const p2 = this.state.players.p2;
            
            const barP1 = document.getElementById('bar-hp-p1');
            if (barP1) {
                barP1.style.width = Math.max(0, p1.hp) + "%";
                barP1.style.backgroundColor = p1.hp > 30 ? '#0f0' : '#f00';
            }

            const barP2 = document.getElementById('bar-hp-p2');
            if (barP2) {
                barP2.style.width = Math.max(0, p2.hp) + "%";
                barP2.style.backgroundColor = p2.hp > 30 ? '#0f0' : '#f00';
            }

            const myUlt = this.state.players[this.myId]?.ult || 0;
            const barUlt = document.getElementById('bar-ult');
            if (barUlt) {
                barUlt.style.width = Math.min(100, Math.max(0, myUlt)) + "%";
            }
            
            const btnUlt = document.getElementById('btn-ult');
            if (btnUlt) {
                if (myUlt >= ULT_MAX) btnUlt.classList.add('ready');
                else btnUlt.classList.remove('ready');
            }

            for(let i=1; i<=3; i++) {
                const el = document.getElementById('ammo-'+i);
                if(i <= this.myAmmo) el.classList.add('ammo-active');
                else el.classList.remove('ammo-active');
            }

            // Reload Bar
            const reloadBar = document.getElementById('reload-bar-fill');
            if (this.myAmmo < AMMO_MAX) {
                const pct = (this.ammoTimer / AMMO_RELOAD_TIME) * 100;
                reloadBar.style.width = pct + "%";
            } else {
                reloadBar.style.width = "0%";
            }
        }

        showResult(winnerId) {
            this.switchLayer('result');
            const title = document.getElementById('result-title');
            const msg = document.getElementById('result-msg');
            
            if (winnerId === 'draw') {
                title.innerText = "DRAW";
                title.className = "draw";
                msg.innerText = "Time Over";
            } else {
                const amIWinner = (winnerId === this.myId);
                if (amIWinner) {
                    title.innerText = "YOU WIN!";
                    title.className = "win";
                    msg.innerText = "Congratulations!";
                } else {
                    title.innerText = "YOU LOSE";
                    title.className = "lose";
                    msg.innerText = "Try again next time.";
                }
            }

            if (this.isHost) {
                document.getElementById('host-controls').classList.remove('hidden');
                document.getElementById('guest-controls').classList.add('hidden');
            } else {
                document.getElementById('host-controls').classList.add('hidden');
                document.getElementById('guest-controls').classList.remove('hidden');
            }
        }

        async restartGame() {
            if (!this.isHost) return;
            
            const now = Date.now();
            this.resetLocalState();
            this.state.remainingTime = GAME_DURATION;
            this.state.startTime = now;
            this.state.status = "playing";

            await updateDoc(doc(db, "rooms", this.roomId), {
                "players.p1.hp": 100,
                "players.p1.x": 100,
                "players.p1.ult": 0,
                "players.p2.hp": 100,
                "players.p2.x": this.canvas.width - 100,
                "players.p2.ult": 0,
                "status": "playing",
                "remainingTime": GAME_DURATION,
                "startTime": now,
                "winner": null
            });
        }

        async disbandRoom() {
            if (!this.isHost) return;
            try {
                await updateDoc(doc(db, "rooms", this.roomId), { status: "closed" });
                location.reload();
            } catch (e) {}
        }

        draw() {
            this.ctx.fillStyle = '#222';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            this.drawStickBase(this.stickLeftBase);
            this.drawStickBase(this.stickRightBase);

            if (this.input.move.active) {
                this.drawStickKnob(this.stickLeftBase, this.input.move.angle);
            } else {
                this.drawStickKnobCentered(this.stickLeftBase);
            }

            if (this.input.aim.active) {
                this.drawStickKnob(this.stickRightBase, this.input.aim.angle);
                
                // Trajectory Line (My Player Only)
                const me = this.state.players[this.myId];
                if (me && me.active) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(me.x, me.y);
                    this.ctx.lineTo(
                        me.x + Math.cos(this.input.aim.angle) * 400, 
                        me.y + Math.sin(this.input.aim.angle) * 400
                    );
                    this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
            } else {
                this.drawStickKnobCentered(this.stickRightBase);
            }

            ['p1', 'p2'].forEach(pid => {
                const p = this.state.players[pid];
                if (!p.active) return;
                
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, PLAYER_RADIUS, 0, Math.PI*2);
                this.ctx.fillStyle = pid === 'p1' ? '#00ccff' : '#00ff00';
                this.ctx.fill();
                
                this.ctx.fillStyle = 'white';
                this.ctx.font = '14px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(p.name, p.x, p.y - 30);

                if (Date.now() < p.slowUntil) {
                    this.ctx.strokeStyle = '#00ffff';
                    this.ctx.lineWidth = 3;
                    this.ctx.stroke();
                } else {
                    this.ctx.strokeStyle = 'white';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                }
            });

            this.particles.forEach(p => {
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, p.size || 2, 0, Math.PI*2);
                this.ctx.fillStyle = p.color;
                this.ctx.fill();
            });

            this.localBullets.forEach(b => {
                this.ctx.beginPath();
                this.ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
                if (b.isUlt) {
                    this.ctx.fillStyle = '#d000ff';
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = '#d000ff';
                } else {
                    this.ctx.fillStyle = '#ffeb3b';
                    this.ctx.shadowBlur = 0;
                }
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            });
        }

        drawStickBase(pos) {
            this.ctx.beginPath();
            this.ctx.arc(pos.x, pos.y, this.stickRadius, 0, Math.PI*2);
            this.ctx.fillStyle = 'rgba(255,255,255,0.1)';
            this.ctx.fill();
            this.ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            this.ctx.lineWidth = 2;
            this.ctx.stroke();
        }

        drawStickKnob(base, angle) {
            this.ctx.beginPath();
            this.ctx.arc(
                base.x + Math.cos(angle) * 40,
                base.y + Math.sin(angle) * 40,
                20, 0, Math.PI*2
            );
            this.ctx.fillStyle = 'rgba(255,255,255,0.5)';
            this.ctx.fill();
        }

        drawStickKnobCentered(base) {
            this.ctx.beginPath();
            this.ctx.arc(base.x, base.y, 20, 0, Math.PI*2);
            this.ctx.fillStyle = 'rgba(255,255,255,0.3)';
            this.ctx.fill();
        }

        loop(timestamp) {
            this.update();
            this.draw();
            requestAnimationFrame((t) => this.loop(t));
        }

        bindButtons() {
            document.getElementById('btn-create').onclick = () => {
                this.initAudio();
                this.createRoom();
            };
            document.getElementById('btn-join').onclick = () => {
                const id = document.getElementById('input-room').value;
                if(id.length === 4) {
                    this.initAudio();
                    this.joinRoom(id);
                } else alert("Enter 4 digits");
            };
            document.getElementById('btn-restart').onclick = () => this.restartGame();
            document.getElementById('btn-close').onclick = () => this.disbandRoom();
            document.getElementById('btn-leave').onclick = () => location.reload();
            document.getElementById('btn-ult').onclick = (e) => {
                e.stopPropagation();
                this.initAudio();
                this.triggerUlt();
            };
        }

        setupInputs() {
            const handleTouch = (e) => {
                e.preventDefault();
                const touches = e.changedTouches;
                for (let i = 0; i < touches.length; i++) {
                    const t = touches[i];
                    const x = t.clientX;
                    const y = t.clientY;

                    // Left Stick
                    const distLeft = Math.hypot(x - this.stickLeftBase.x, y - this.stickLeftBase.y);
                    if (distLeft < 100) {
                        this.input.move.active = true;
                        this.input.move.id = t.identifier;
                        this.input.move.angle = Math.atan2(y - this.stickLeftBase.y, x - this.stickLeftBase.x);
                        continue;
                    }

                    // Right Stick
                    const ultRect = document.getElementById('btn-ult').getBoundingClientRect();
                    if (x >= ultRect.left && x <= ultRect.right && y >= ultRect.top && y <= ultRect.bottom) {
                        continue;
                    }

                    const distRight = Math.hypot(x - this.stickRightBase.x, y - this.stickRightBase.y);
                    if (distRight < 100) {
                        this.input.aim.active = true;
                        this.input.aim.id = t.identifier;
                        this.input.aim.angle = Math.atan2(y - this.stickRightBase.y, x - this.stickRightBase.x);
                        continue;
                    }
                }
            };

            const handleMove = (e) => {
                e.preventDefault();
                const touches = e.changedTouches;
                for (let i = 0; i < touches.length; i++) {
                    const t = touches[i];
                    const x = t.clientX;
                    const y = t.clientY;

                    if (this.input.move.active && this.input.move.id === t.identifier) {
                        this.input.move.angle = Math.atan2(y - this.stickLeftBase.y, x - this.stickLeftBase.x);
                    }
                    if (this.input.aim.active && this.input.aim.id === t.identifier) {
                        this.input.aim.angle = Math.atan2(y - this.stickRightBase.y, x - this.stickRightBase.x);
                    }
                }
            };

            const handleEnd = (e) => {
                e.preventDefault();
                const touches = e.changedTouches;
                for (let i = 0; i < touches.length; i++) {
                    const t = touches[i];
                    if (this.input.move.id === t.identifier) {
                        this.input.move.active = false;
                        this.input.move.id = null;
                    }
                    if (this.input.aim.id === t.identifier) {
                        this.tryFire(this.input.aim.angle);
                        this.input.aim.active = false;
                        this.input.aim.id = null;
                    }
                }
            };

            this.canvas.addEventListener('touchstart', handleTouch, {passive: false});
            this.canvas.addEventListener('touchmove', handleMove, {passive: false});
            this.canvas.addEventListener('touchend', handleEnd, {passive: false});
        }
    }

    window.onload = () => new Game();
</script>
</body>
</html>
