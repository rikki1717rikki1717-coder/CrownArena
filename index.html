<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Firestore Only Shooter</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            color: white;
            font-family: monospace;
            touch-action: none;
            user-select: none;
        }

        canvas {
            display: block;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10;
        }

        .panel {
            background: #2a2a2a;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid #444;
            width: 300px;
            max-width: 90%;
        }

        h1 { margin: 0 0 20px 0; color: #ff9800; font-size: 20px; }

        input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 16px;
            text-align: center;
        }

        button {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            color: white;
        }

        .btn-host { background: #0078d7; }
        .btn-join { background: #107c10; }

        #room-display {
            font-size: 32px;
            font-weight: bold;
            color: #ffeb3b;
            letter-spacing: 5px;
            margin: 15px 0;
            background: #000;
            padding: 10px;
            border-radius: 4px;
        }

        #status-msg { margin-top: 10px; color: #aaa; font-size: 12px; }

        /* HUD */
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            font-size: 14px;
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="panel" id="panel-menu">
            <h1>Firestore Battle</h1>
            <button class="btn-host" id="btn-create">Create Room (Host)</button>
            <div style="margin: 10px 0; color:#666;">- OR -</div>
            <input type="number" id="input-room" placeholder="4-Digit Room ID">
            <button class="btn-join" id="btn-join">Join Room</button>
            <div id="status-msg">Ready</div>
        </div>

        <div class="panel" id="panel-wait" style="display: none;">
            <h1>Waiting for P2...</h1>
            <div>Room ID:</div>
            <div id="room-display">----</div>
            <div style="font-size: 12px; color: #aaa;">Share this ID with your friend</div>
        </div>
    </div>

    <div id="hud">
        P1: <span id="hp-p1">100</span> | P2: <span id="hp-p2">100</span>
        <br>
        Room: <span id="hud-room">----</span>
    </div>

    <canvas id="gameCanvas"></canvas>

<script type="module">
    // ---------------------------------------------------------
    // 1. Firebase Config (Modular SDK v9/v10)
    // ---------------------------------------------------------
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { 
        getFirestore, doc, setDoc, updateDoc, onSnapshot, getDoc 
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    const firebaseConfig = {
        apiKey: "AIzaSyA8B-JtwDskK3omhjUCbjERHBZ6UDdm854",
        authDomain: "crownarena-1a321.firebaseapp.com",
        projectId: "crownarena-1a321",
        storageBucket: "crownarena-1a321.firebasestorage.app",
        messagingSenderId: "103440875843",
        appId: "1:103440875843:web:d34b314c4df7e0d491aff6",
        measurementId: "G-N9KDL9B9Y5"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    console.log("Firebase initialized");

    // ---------------------------------------------------------
    // 2. Constants & Globals
    // ---------------------------------------------------------
    const CANVAS = document.getElementById('gameCanvas');
    const CTX = CANVAS.getContext('2d');
    
    // Game Config
    const PLAYER_RADIUS = 20;
    const BULLET_RADIUS = 5;
    const MOVE_SPEED = 5;
    const BULLET_SPEED = 10;
    const FIRE_RATE = 200; // ms
    
    // Network Config
    const SYNC_INTERVAL = 100; // 100msごとにFirestore同期 (負荷軽減)

    // ---------------------------------------------------------
    // 3. Game Logic Class
    // ---------------------------------------------------------
    class Game {
        constructor() {
            this.roomId = null;
            this.isHost = false; // P1 = Host, P2 = Guest
            this.myId = null;    // 'p1' or 'p2'
            
            this.state = {
                players: {
                    p1: { x: 100, y: 100, hp: 100, lives: 3, isShooting: false, active: false },
                    p2: { x: 300, y: 100, hp: 100, lives: 3, isShooting: false, active: false }
                },
                bullets: [], // [{x, y, vx, vy, owner}]
                status: "waiting"
            };

            // Input
            this.input = { x: 0, y: 0, fire: false };
            this.touchId = null;
            this.stickBase = { x: 100, y: 300 };
            
            // Timers
            this.lastSyncTime = 0;
            this.lastFireTime = 0;

            this.resize();
            window.addEventListener('resize', () => this.resize());
            this.setupInputs();
            
            // UI References
            this.uiMenu = document.getElementById('panel-menu');
            this.uiWait = document.getElementById('panel-wait');
            this.uiLayer = document.getElementById('ui-layer');
            this.statusMsg = document.getElementById('status-msg');
            
            this.bindButtons();

            // Start Loop
            requestAnimationFrame((t) => this.loop(t));
        }

        resize() {
            CANVAS.width = window.innerWidth;
            CANVAS.height = window.innerHeight;
            this.stickBase = { x: 120, y: CANVAS.height - 120 };
        }

        // --- Network Actions ---

        async createRoom() {
            this.roomId = Math.floor(1000 + Math.random() * 9000).toString();
            this.isHost = true;
            this.myId = 'p1';
            
            const initialData = {
                players: {
                    p1: { ...this.state.players.p1, active: true },
                    p2: { ...this.state.players.p2, active: false }
                },
                bullets: [],
                status: "waiting"
            };

            await setDoc(doc(db, "rooms", this.roomId), initialData);
            
            this.uiMenu.style.display = 'none';
            this.uiWait.style.display = 'block';
            document.getElementById('room-display').innerText = this.roomId;
            document.getElementById('hud-room').innerText = this.roomId;

            this.subscribeToRoom();
        }

        async joinRoom(id) {
            const docRef = doc(db, "rooms", id);
            const snap = await getDoc(docRef);
            
            if (!snap.exists()) {
                alert("Room not found!");
                return;
            }

            this.roomId = id;
            this.isHost = false;
            this.myId = 'p2';

            // P2 Active化
            await updateDoc(docRef, {
                "players.p2.active": true,
                "status": "playing"
            });

            this.uiMenu.style.display = 'none';
            this.uiLayer.style.display = 'none';
            document.getElementById('hud-room').innerText = this.roomId;

            this.subscribeToRoom();
        }

        subscribeToRoom() {
            onSnapshot(doc(db, "rooms", this.roomId), (doc) => {
                if (!doc.exists()) return;
                const data = doc.data();
                
                // --- Sync Logic ---
                // 自分のデータは上書きせず、相手のデータと共有データ(弾、HP)を取り込む

                if (this.isHost) {
                    // Host (P1) は P2の「位置」と「操作」だけ受け取る
                    // HPや弾は自分が計算して書き込む側なので、Firestoreからは読まない（上書き防止）
                    if (data.players.p2) {
                        this.state.players.p2.x = data.players.p2.x;
                        this.state.players.p2.y = data.players.p2.y;
                        this.state.players.p2.isShooting = data.players.p2.isShooting;
                        this.state.players.p2.active = data.players.p2.active;
                    }
                } else {
                    // Guest (P2) は P1の全データ と 弾 と 自分のHP/Lives (Hostが計算) を受け取る
                    if (data.players.p1) this.state.players.p1 = data.players.p1;
                    if (data.bullets) this.state.bullets = data.bullets;
                    // 自分のHPはHostが管理しているので同期する
                    if (data.players.p2) {
                        this.state.players.p2.hp = data.players.p2.hp;
                        this.state.players.p2.lives = data.players.p2.lives;
                    }
                    if (data.status === "playing") {
                        this.uiLayer.style.display = 'none';
                    }
                }
                
                // HUD更新
                document.getElementById('hp-p1').innerText = this.state.players.p1.hp;
                document.getElementById('hp-p2').innerText = this.state.players.p2.hp;
            });
        }

        async syncToFirestore() {
            if (!this.roomId) return;
            const ref = doc(db, "rooms", this.roomId);

            try {
                if (this.isHost) {
                    // Hostは P1位置, P1操作, 全弾丸, 全HP を書き込む
                    // Dot notationで必要な部分だけ更新
                    await updateDoc(ref, {
                        "players.p1": this.state.players.p1,
                        "players.p2.hp": this.state.players.p2.hp, // Host権限でHP更新
                        "players.p2.lives": this.state.players.p2.lives,
                        "bullets": this.state.bullets
                    });
                } else {
                    // Guestは P2位置, P2操作 のみを書き込む (active維持)
                    await updateDoc(ref, {
                        "players.p2.x": this.state.players.p2.x,
                        "players.p2.y": this.state.players.p2.y,
                        "players.p2.isShooting": this.state.players.p2.isShooting
                    });
                }
            } catch (e) {
                console.error("Sync Error:", e);
            }
        }

        // --- Game Loop ---

        update(dt) {
            // 1. 自分の移動更新
            const me = this.state.players[this.myId];
            me.x += this.input.x * MOVE_SPEED;
            me.y += this.input.y * MOVE_SPEED;
            // 画面外制限
            me.x = Math.max(20, Math.min(CANVAS.width - 20, me.x));
            me.y = Math.max(20, Math.min(CANVAS.height - 20, me.y));

            // 射撃フラグ更新
            me.isShooting = this.input.fire;

            // 2. Hostのみが実行する処理 (弾の生成・移動・衝突)
            if (this.isHost) {
                this.hostGameLogic();
            }

            // 3. 定期的なネットワーク同期
            const now = Date.now();
            if (now - this.lastSyncTime > SYNC_INTERVAL) {
                this.syncToFirestore();
                this.lastSyncTime = now;
            }
        }

        hostGameLogic() {
            // 弾の生成 (P1 & P2)
            ['p1', 'p2'].forEach(pid => {
                const p = this.state.players[pid];
                if (p.active && p.isShooting) {
                    // シンプルな連射制限
                    // 注: 本格的には各プレイヤーごとのLastFireが必要だが、ここでは簡易化
                    // 乱数でバラけさせるか、確率で生成して連射速度っぽくする
                    if (Math.random() < 0.1) { // 約 6発/秒
                        let vx = 0, vy = 0;
                        if (pid === 'p1') vx = BULLET_SPEED; // P1は右へ
                        else vx = -BULLET_SPEED;             // P2は左へ
                        
                        this.state.bullets.push({
                            x: p.x, y: p.y, vx: vx, vy: 0, owner: pid
                        });
                    }
                }
            });

            // 弾の移動 & 削除
            this.state.bullets.forEach(b => {
                b.x += b.vx;
                b.y += b.vy;
            });
            // 画面外削除
            this.state.bullets = this.state.bullets.filter(b => 
                b.x > 0 && b.x < CANVAS.width && b.y > 0 && b.y < CANVAS.height
            );

            // 当たり判定 (Server Authority)
            this.state.bullets = this.state.bullets.filter(b => {
                let hit = false;
                // ターゲット特定
                const targetId = b.owner === 'p1' ? 'p2' : 'p1';
                const target = this.state.players[targetId];

                if (target.active && target.lives > 0) {
                    const dx = b.x - target.x;
                    const dy = b.y - target.y;
                    if (Math.hypot(dx, dy) < PLAYER_RADIUS + BULLET_RADIUS) {
                        hit = true;
                        target.hp -= 10;
                        if (target.hp <= 0) {
                            target.hp = 100;
                            target.lives--;
                        }
                    }
                }
                return !hit; // 当たったら消える
            });
        }

        draw() {
            // BG
            CTX.fillStyle = '#222';
            CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

            // Players
            ['p1', 'p2'].forEach(pid => {
                const p = this.state.players[pid];
                if (!p.active) return;
                
                CTX.beginPath();
                CTX.arc(p.x, p.y, PLAYER_RADIUS, 0, Math.PI*2);
                CTX.fillStyle = pid === 'p1' ? '#00ccff' : '#00ff00';
                CTX.fill();
                
                // HP Bar
                CTX.fillStyle = 'red';
                CTX.fillRect(p.x - 20, p.y - 35, 40, 5);
                CTX.fillStyle = '#0f0';
                CTX.fillRect(p.x - 20, p.y - 35, 40 * (p.hp/100), 5);
            });

            // Bullets
            CTX.fillStyle = '#ffeb3b';
            this.state.bullets.forEach(b => {
                CTX.beginPath();
                CTX.arc(b.x, b.y, BULLET_RADIUS, 0, Math.PI*2);
                CTX.fill();
            });

            // Stick (UI)
            CTX.beginPath();
            CTX.arc(this.stickBase.x, this.stickBase.y, 50, 0, Math.PI*2);
            CTX.strokeStyle = 'rgba(255,255,255,0.3)';
            CTX.lineWidth = 2;
            CTX.stroke();
            
            CTX.beginPath();
            CTX.arc(this.stickBase.x + this.input.x*50, this.stickBase.y + this.input.y*50, 25, 0, Math.PI*2);
            CTX.fillStyle = 'rgba(255,255,255,0.5)';
            CTX.fill();
            
            // Fire Button (Right side)
            const fireX = CANVAS.width - 100;
            const fireY = CANVAS.height - 120;
            CTX.beginPath();
            CTX.arc(fireX, fireY, 40, 0, Math.PI*2);
            CTX.fillStyle = this.input.fire ? 'rgba(255,0,0,0.6)' : 'rgba(255,0,0,0.3)';
            CTX.fill();
            CTX.strokeStyle = 'white';
            CTX.stroke();
            CTX.fillStyle = 'white';
            CTX.font = '14px Arial';
            CTX.textAlign = 'center';
            CTX.fillText("FIRE", fireX, fireY + 5);
        }

        loop(timestamp) {
            this.update();
            this.draw();
            requestAnimationFrame((t) => this.loop(t));
        }

        // --- Inputs ---
        bindButtons() {
            document.getElementById('btn-create').onclick = () => this.createRoom();
            document.getElementById('btn-join').onclick = () => {
                const id = document.getElementById('input-room').value;
                if(id.length === 4) this.joinRoom(id);
                else alert("Enter 4 digits");
            };
        }

        setupInputs() {
            const handleTouch = (e) => {
                e.preventDefault();
                const touches = e.changedTouches;
                for (let i = 0; i < touches.length; i++) {
                    const t = touches[i];
                    
                    // Left Stick
                    if (t.clientX < CANVAS.width / 2) {
                        this.touchId = t.identifier;
                        const dx = t.clientX - this.stickBase.x;
                        const dy = t.clientY - this.stickBase.y;
                        const dist = Math.hypot(dx, dy);
                        const max = 50;
                        
                        if (dist > max) {
                            this.input.x = (dx / dist);
                            this.input.y = (dy / dist);
                        } else {
                            this.input.x = dx / max;
                            this.input.y = dy / max;
                        }
                    } 
                    // Right Fire Button
                    else {
                        const fireX = CANVAS.width - 100;
                        const fireY = CANVAS.height - 120;
                        const dist = Math.hypot(t.clientX - fireX, t.clientY - fireY);
                        if (dist < 60) {
                            this.input.fire = true;
                        }
                    }
                }
            };

            const handleEnd = (e) => {
                e.preventDefault();
                const touches = e.changedTouches;
                for (let i = 0; i < touches.length; i++) {
                    const t = touches[i];
                    if (t.identifier === this.touchId) {
                        this.input.x = 0;
                        this.input.y = 0;
                        this.touchId = null;
                    }
                    if (t.clientX > CANVAS.width / 2) {
                        this.input.fire = false;
                    }
                }
            };

            CANVAS.addEventListener('touchstart', handleTouch, {passive: false});
            CANVAS.addEventListener('touchmove', handleTouch, {passive: false});
            CANVAS.addEventListener('touchend', handleEnd, {passive: false});
        }
    }

    // Init
    window.onload = () => new Game();
</script>
</body>
</html>
