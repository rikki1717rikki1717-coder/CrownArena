<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Firebase Shooter V10 Stable</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* スマホでのスクロール無効化 */
            user-select: none;
        }

        canvas {
            display: block;
        }

        /* UIオーバーレイ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10;
            transition: opacity 0.5s;
        }

        .panel {
            background: #2a2a2a;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid #444;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 90%;
            width: 320px;
        }

        h1 { margin: 0 0 20px 0; font-size: 24px; color: #4dc3ff; }
        
        input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 6px;
            box-sizing: border-box;
            font-size: 16px;
            text-align: center;
        }

        button {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn-host { background: #0078d7; color: white; }
        .btn-host:active { background: #005a9e; }
        
        .btn-join { background: #107c10; color: white; }
        .btn-join:active { background: #0b5a0b; }

        #status-text {
            margin-top: 15px;
            font-size: 14px;
            color: #aaa;
            min-height: 20px;
        }

        .room-code {
            font-size: 32px;
            font-weight: bold;
            color: #ffeb3b;
            letter-spacing: 5px;
            margin: 10px 0;
            background: #000;
            padding: 10px;
            border-radius: 4px;
        }

        /* ゲーム画面のステータス表示 */
        #game-hud {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            font-size: 14px;
            color: #00ff00;
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="panel" id="panel-menu">
            <h1>Shooter Online</h1>
            <input type="text" id="input-name" placeholder="Enter Nickname" value="Player">
            <button class="btn-host" id="btn-create">Create Room</button>
            <div style="margin: 10px 0; color: #666;">- OR -</div>
            <input type="number" id="input-room-id" placeholder="Room ID (4 digits)">
            <button class="btn-join" id="btn-join">Join Room</button>
            <div id="status-text">Ready to connect.</div>
        </div>

        <div class="panel" id="panel-waiting" style="display: none;">
            <h1>Waiting for P2...</h1>
            <p>Share this Room ID:</p>
            <div class="room-code" id="display-room-id">----</div>
            <div id="waiting-status">Creating room...</div>
        </div>
    </div>

    <div id="game-hud">
        Status: <span id="connection-status">Offline</span>
    </div>

    <canvas id="gameCanvas"></canvas>

<script type="module">
    // ---------------------------------------------------------
    // 1. Firebase Configuration & Imports (V10 Modular)
    // ---------------------------------------------------------
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { 
        getFirestore, collection, doc, setDoc, getDoc, updateDoc, 
        onSnapshot, addDoc 
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    const firebaseConfig = {
        apiKey: "AIzaSyA8B-JtwDskK3omhjUCbjERHBZ6UDdm854",
        authDomain: "crownarena-1a321.firebaseapp.com",
        projectId: "crownarena-1a321",
        storageBucket: "crownarena-1a321.firebasestorage.app",
        messagingSenderId: "103440875843",
        appId: "1:103440875843:web:d34b314c4df7e0d491aff6",
        measurementId: "G-N9KDL9B9Y5"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    console.log("Firebase Initialized");

    // ---------------------------------------------------------
    // 2. Network Manager (WebRTC + Firestore Signaling)
    // ---------------------------------------------------------
    class NetworkManager {
        constructor() {
            this.pc = null;
            this.dc = null; // DataChannel
            this.roomId = null;
            this.isHost = false;
            this.remoteCandidatesQueue = []; // ICE候補待機キュー
            
            // 公開STUNサーバー
            this.rtcConfig = {
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            };

            // コールバック関数（Gameクラスからセットされる）
            this.onConnect = () => {};
            this.onData = (data) => {};
            this.onStatus = (msg) => {};
        }

        // 共通: PeerConnection作成
        createPeerConnection() {
            this.pc = new RTCPeerConnection(this.rtcConfig);

            // 接続状態の監視
            this.pc.onconnectionstatechange = () => {
                console.log("WebRTC State:", this.pc.connectionState);
                if (this.pc.connectionState === 'connected') {
                    this.onStatus("Connected!");
                }
            };
        }

        // DataChannelセットアップ (メッセージ受信)
        setupDataChannel(channel) {
            this.dc = channel;
            this.dc.onopen = () => {
                console.log("DataChannel OPEN");
                this.onConnect(); // ゲーム開始トリガー
            };
            this.dc.onmessage = (e) => {
                // 受信データはJSONパースしてゲームへ渡す
                try {
                    const data = JSON.parse(e.data);
                    this.onData(data);
                } catch (err) {
                    console.error("Data parse error", err);
                }
            };
        }

        // データを送信
        send(data) {
            if (this.dc && this.dc.readyState === 'open') {
                this.dc.send(JSON.stringify(data));
            }
        }

        // ICE Candidateの収集と交換ロジック
        async collectIceCandidates(roomRef, localName, remoteName) {
            const localCandidatesCol = collection(roomRef, localName);
            const remoteCandidatesCol = collection(roomRef, remoteName);

            // 1. 自分のICE候補が出たらFirestoreに保存
            this.pc.onicecandidate = async (event) => {
                if (event.candidate) {
                    try {
                        await addDoc(localCandidatesCol, event.candidate.toJSON());
                    } catch (e) {
                        console.error("Error adding candidate:", e);
                    }
                }
            };

            // 2. 相手のICE候補を監視
            onSnapshot(remoteCandidatesCol, (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === 'added') {
                        const candidate = new RTCIceCandidate(change.doc.data());
                        // 重要: RemoteDescriptionがまだ設定されていない場合はキューに入れる
                        if (!this.pc.remoteDescription) {
                            console.log("Queueing remote candidate");
                            this.remoteCandidatesQueue.push(candidate);
                        } else {
                            await this.pc.addIceCandidate(candidate);
                        }
                    }
                });
            });
        }

        // キューに溜まったICE候補を処理する
        async processCandidateQueue() {
            console.log(`Processing ${this.remoteCandidatesQueue.length} queued candidates`);
            for (const candidate of this.remoteCandidatesQueue) {
                await this.pc.addIceCandidate(candidate);
            }
            this.remoteCandidatesQueue = [];
        }

        // --- HOST 処理 ---
        async createRoom() {
            this.isHost = true;
            this.createPeerConnection();
            
            // HostがDataChannelを作成
            const channel = this.pc.createDataChannel("game");
            this.setupDataChannel(channel);

            // ルームID生成 (ランダム4桁)
            this.roomId = Math.floor(1000 + Math.random() * 9000).toString();
            const roomRef = doc(db, 'rooms', this.roomId);

            // Offer作成
            const offer = await this.pc.createOffer();
            await this.pc.setLocalDescription(offer);

            // FirestoreにOffer保存
            const roomData = {
                offer: { type: offer.type, sdp: offer.sdp },
                createdAt: new Date()
            };
            await setDoc(roomRef, roomData);

            // ICE交換開始 (Hostは callerCandidates に書き込み)
            this.collectIceCandidates(roomRef, 'callerCandidates', 'calleeCandidates');

            // Answer待ち受け
            onSnapshot(roomRef, async (snapshot) => {
                const data = snapshot.data();
                if (!this.pc.currentRemoteDescription && data && data.answer) {
                    console.log("Answer received!");
                    const answer = new RTCSessionDescription(data.answer);
                    await this.pc.setRemoteDescription(answer);
                    // RemoteDescriptionセット後に待機中のICE候補を適用
                    await this.processCandidateQueue();
                }
            });

            return this.roomId;
        }

        // --- JOIN 処理 ---
        async joinRoom(roomId) {
            this.isHost = false;
            this.roomId = roomId;
            const roomRef = doc(db, 'rooms', roomId);
            const roomSnapshot = await getDoc(roomRef);

            if (!roomSnapshot.exists()) {
                throw new Error("Room not found");
            }

            this.createPeerConnection();

            // JoinerはDataChannelを受け取るイベントを設定
            this.pc.ondatachannel = (e) => {
                this.setupDataChannel(e.channel);
            };

            // Offer取得 & Remote設定
            const offer = roomSnapshot.data().offer;
            await this.pc.setRemoteDescription(new RTCSessionDescription(offer));
            // Remote設定できたので、もし既にICEが来ていれば処理したいが、Join側はまだリスナー起動前

            // Answer作成 & Local設定
            const answer = await this.pc.createAnswer();
            await this.pc.setLocalDescription(answer);

            // Answer保存
            await updateDoc(roomRef, {
                answer: { type: answer.type, sdp: answer.sdp }
            });

            // ICE交換開始 (Joinは calleeCandidates に書き込み)
            await this.collectIceCandidates(roomRef, 'calleeCandidates', 'callerCandidates');
            
            // Join側はRemoteセット済みなので、監視開始直後のSnapshotでICEが来れば即適用される
        }
    }

    // ---------------------------------------------------------
    // 3. Game Logic (Canvas & Input)
    // ---------------------------------------------------------
    class Game {
        constructor() {
            this.canvas = document.getElementById('gameCanvas');
            this.ctx = this.canvas.getContext('2d');
            this.resize();

            // ネットワーク管理
            this.network = new NetworkManager();
            this.bindNetworkEvents();

            // プレイヤー状態
            this.localPlayer = { x: 100, y: 100, color: '#00ccff', id: 1 };
            this.remotePlayer = { x: 300, y: 100, color: '#00ff00', id: 2 };
            
            // 入力管理
            this.input = { x: 0, y: 0 };
            this.touchId = null;
            this.stickBase = { x: 100, y: 0 }; // resizeで調整

            // UI要素
            this.uiMenu = document.getElementById('panel-menu');
            this.uiWaiting = document.getElementById('panel-waiting');
            this.uiLayer = document.getElementById('ui-layer');
            this.statusText = document.getElementById('status-text');
            this.hudStatus = document.getElementById('connection-status');

            // イベントリスナー設定
            window.addEventListener('resize', () => this.resize());
            this.setupUI();
            this.setupTouch();

            // ゲームループ開始
            this.lastTime = 0;
            requestAnimationFrame((t) => this.loop(t));
        }

        resize() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            // スティック位置調整（左下）
            this.stickBase = { x: 120, y: this.canvas.height - 120 };
        }

        bindNetworkEvents() {
            // 接続完了時
            this.network.onConnect = () => {
                this.uiLayer.style.opacity = '0';
                setTimeout(() => { this.uiLayer.style.display = 'none'; }, 500);
                this.hudStatus.innerText = "Online";
                this.hudStatus.style.color = "#00ff00";
            };

            // データ受信時 (相手の座標更新)
            this.network.onData = (data) => {
                if (data.type === 'move') {
                    this.remotePlayer.x = data.x;
                    this.remotePlayer.y = data.y;
                }
            };

            // ステータス表示更新
            this.network.onStatus = (msg) => {
                this.statusText.innerText = msg;
                document.getElementById('waiting-status').innerText = msg;
            };
        }

        setupUI() {
            const btnCreate = document.getElementById('btn-create');
            const btnJoin = document.getElementById('btn-join');
            const inputRoomId = document.getElementById('input-room-id');
            const displayRoomId = document.getElementById('display-room-id');

            // Create Room
            btnCreate.onclick = async () => {
                btnCreate.disabled = true;
                btnJoin.disabled = true;
                this.statusText.innerText = "Creating room...";
                
                try {
                    const roomId = await this.network.createRoom();
                    this.localPlayer.id = 1; // Host is P1
                    this.localPlayer.color = '#00ccff';
                    this.localPlayer.x = 100;

                    this.uiMenu.style.display = 'none';
                    this.uiWaiting.style.display = 'block';
                    displayRoomId.innerText = roomId;
                } catch (e) {
                    console.error(e);
                    alert("Error creating room: " + e.message);
                    btnCreate.disabled = false;
                    btnJoin.disabled = false;
                }
            };

            // Join Room
            btnJoin.onclick = async () => {
                const roomId = inputRoomId.value.trim();
                if (roomId.length !== 4) {
                    alert("Please enter a valid 4-digit ID");
                    return;
                }
                
                btnCreate.disabled = true;
                btnJoin.disabled = true;
                this.statusText.innerText = "Joining...";

                try {
                    await this.network.joinRoom(roomId);
                    this.localPlayer.id = 2; // Joiner is P2
                    this.localPlayer.color = '#00ff00';
                    this.localPlayer.x = this.canvas.width - 100;
                    // 成功したらWebRTC接続待ちになるのでUIはそのまま
                } catch (e) {
                    console.error(e);
                    alert("Error joining: " + e.message);
                    btnCreate.disabled = false;
                    btnJoin.disabled = false;
                    this.statusText.innerText = "Join failed.";
                }
            };
        }

        setupTouch() {
            const handleStart = (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    // 左画面半分をスティック領域とする
                    if (t.clientX < this.canvas.width / 2 && this.touchId === null) {
                        this.touchId = t.identifier;
                        this.updateStick(t.clientX, t.clientY);
                    }
                }
            };

            const handleMove = (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if (t.identifier === this.touchId) {
                        this.updateStick(t.clientX, t.clientY);
                    }
                }
            };

            const handleEnd = (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === this.touchId) {
                        this.touchId = null;
                        this.input = { x: 0, y: 0 };
                    }
                }
            };

            this.canvas.addEventListener('touchstart', handleStart, { passive: false });
            this.canvas.addEventListener('touchmove', handleMove, { passive: false });
            this.canvas.addEventListener('touchend', handleEnd, { passive: false });
        }

        updateStick(x, y) {
            const maxDist = 50;
            let dx = x - this.stickBase.x;
            let dy = y - this.stickBase.y;
            const dist = Math.hypot(dx, dy);
            
            // 正規化
            if (dist > maxDist) {
                dx = (dx / dist) * maxDist;
                dy = (dy / dist) * maxDist;
            }
            
            // 入力値 (-1 ~ 1)
            this.input.x = dx / maxDist;
            this.input.y = dy / maxDist;
        }

        update() {
            // ローカルプレイヤーの移動
            const speed = 5;
            this.localPlayer.x += this.input.x * speed;
            this.localPlayer.y += this.input.y * speed;

            // 画面外制限
            const r = 20;
            this.localPlayer.x = Math.max(r, Math.min(this.canvas.width - r, this.localPlayer.x));
            this.localPlayer.y = Math.max(r, Math.min(this.canvas.height - r, this.localPlayer.y));

            // ネットワーク送信 (DataChannelが開通している場合)
            if (this.network.dc && this.network.dc.readyState === 'open') {
                this.network.send({
                    type: 'move',
                    x: this.localPlayer.x,
                    y: this.localPlayer.y
                });
            }
        }

        draw() {
            // 画面クリア
            this.ctx.fillStyle = '#1a1a1a';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            // グリッド描画（見た目用）
            this.ctx.strokeStyle = '#333';
            this.ctx.lineWidth = 1;
            for(let x=0; x<this.canvas.width; x+=50) {
                this.ctx.beginPath(); this.ctx.moveTo(x,0); this.ctx.lineTo(x,this.canvas.height); this.ctx.stroke();
            }
            for(let y=0; y<this.canvas.height; y+=50) {
                this.ctx.beginPath(); this.ctx.moveTo(0,y); this.ctx.lineTo(this.canvas.width,y); this.ctx.stroke();
            }

            // プレイヤー描画関数
            const drawPlayer = (p) => {
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, 20, 0, Math.PI * 2);
                this.ctx.fillStyle = p.color;
                this.ctx.fill();
                this.ctx.lineWidth = 3;
                this.ctx.strokeStyle = 'white';
                this.ctx.stroke();
                
                // 名前
                this.ctx.fillStyle = 'white';
                this.ctx.font = '14px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(p.id === this.localPlayer.id ? "YOU" : "ENEMY", p.x, p.y - 30);
            };

            drawPlayer(this.localPlayer);
            drawPlayer(this.remotePlayer);

            // スティック描画
            this.ctx.beginPath();
            this.ctx.arc(this.stickBase.x, this.stickBase.y, 50, 0, Math.PI*2);
            this.ctx.fillStyle = 'rgba(255,255,255,0.1)';
            this.ctx.fill();
            this.ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            this.ctx.stroke();

            this.ctx.beginPath();
            this.ctx.arc(
                this.stickBase.x + this.input.x * 50, 
                this.stickBase.y + this.input.y * 50, 
                25, 0, Math.PI*2
            );
            this.ctx.fillStyle = 'rgba(255,255,255,0.5)';
            this.ctx.fill();
        }

        loop(timestamp) {
            this.update();
            this.draw();
            requestAnimationFrame((t) => this.loop(t));
        }
    }

    // ゲーム起動
    window.onload = () => {
        new Game();
    };
</script>
</body>
</html>
