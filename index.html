<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2-Player Versus Shooter</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #222;
            touch-action: none;
            font-family: Arial, sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * ユーティリティ: ベクトル計算用
 */
class Vec2 {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

/**
 * InputManagerクラス
 * P1（スティック）とP2（ボタン）の入力を管理
 */
class InputManager {
    constructor(canvas) {
        this.canvas = canvas;
        
        // --- Player 1 (Stick & Btn) ---
        this.p1 = {
            moveVector: new Vec2(0, 0),
            btnActive: false,
            // UI配置
            stickBase: new Vec2(150, canvas.height - 150),
            stickPos: new Vec2(0, 0),
            stickRadius: 60,
            btnPos: new Vec2(canvas.width - 150, canvas.height - 150),
            btnRadius: 50,
            // タッチID管理
            stickTouchId: null,
            btnTouchId: null
        };

        // --- Player 2 (D-Pad & Btn) ---
        // 右上に配置
        this.p2 = {
            moveVector: new Vec2(0, 0),
            btnActive: false,
            // ボタン定義 (x, y, w, h, id)
            buttons: [],
            activeTouches: {} // touchId -> buttonId
        };

        // UIタップ用（リトライボタン等）
        this.lastTap = null;

        this.updateLayout(canvas.width, canvas.height);
        this.setupEvents();
    }

    updateLayout(width, height) {
        // P1 Layout (Bottom Left/Right)
        this.p1.stickBase = new Vec2(120, height - 120);
        this.p1.btnPos = new Vec2(width - 120, height - 120);

        // P2 Layout (Top Right - 簡易ボタン)
        const size = 40;
        const gap = 5;
        const baseX = width - 180;
        const baseY = 20;

        // 上下左右 + 射撃(F)
        this.p2.buttons = [
            { id: 'U', x: baseX + size + gap, y: baseY, w: size, h: size },
            { id: 'L', x: baseX, y: baseY + size + gap, w: size, h: size },
            { id: 'D', x: baseX + size + gap, y: baseY + (size + gap) * 2, w: size, h: size },
            { id: 'R', x: baseX + (size + gap) * 2, y: baseY + size + gap, w: size, h: size },
            { id: 'F', x: baseX + (size + gap) * 3 + 20, y: baseY + size + gap, w: 50, h: 50 } // Fire
        ];
    }

    setupEvents() {
        const handleTouch = (e, type) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                const x = t.clientX;
                const y = t.clientY;

                if (type === 'start') {
                    this.lastTap = { x: x, y: y }; // UI判定用
                    
                    // --- P1 Logic ---
                    // スティック (画面左半分 & 下半分)
                    if (x < this.canvas.width / 2 && y > this.canvas.height / 2 && !this.p1.stickActive) {
                        this.p1.stickActive = true;
                        this.p1.stickTouchId = t.identifier;
                        this.updateP1Stick(x, y);
                    }
                    // 射撃 (画面右半分 & 下半分)
                    else if (x >= this.canvas.width / 2 && y > this.canvas.height / 2) {
                        const dist = Math.hypot(x - this.p1.btnPos.x, y - this.p1.btnPos.y);
                        if (dist < 100) {
                            this.p1.btnActive = true;
                            this.p1.btnTouchId = t.identifier;
                        }
                    }

                    // --- P2 Logic (Top Right Buttons) ---
                    // ボタン当たり判定
                    this.p2.buttons.forEach(btn => {
                        if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                            this.p2.activeTouches[t.identifier] = btn.id;
                        }
                    });
                    this.updateP2Input();
                }
                else if (type === 'move') {
                    // P1 Stick
                    if (t.identifier === this.p1.stickTouchId) {
                        this.updateP1Stick(x, y);
                    }
                    // P2 Button Slide (簡易的に、移動してもボタンエリア内なら維持などの処理は省略し、Start判定のみ重視)
                }
                else if (type === 'end') {
                    // P1
                    if (t.identifier === this.p1.stickTouchId) {
                        this.p1.stickActive = false;
                        this.p1.stickTouchId = null;
                        this.p1.stickPos.x = 0;
                        this.p1.stickPos.y = 0;
                        this.p1.moveVector.x = 0;
                        this.p1.moveVector.y = 0;
                    }
                    if (t.identifier === this.p1.btnTouchId) {
                        this.p1.btnActive = false;
                        this.p1.btnTouchId = null;
                    }

                    // P2
                    if (this.p2.activeTouches[t.identifier]) {
                        delete this.p2.activeTouches[t.identifier];
                        this.updateP2Input();
                    }
                }
            }
        };

        this.canvas.addEventListener('touchstart', (e) => handleTouch(e, 'start'), { passive: false });
        this.canvas.addEventListener('touchmove', (e) => handleTouch(e, 'move'), { passive: false });
        this.canvas.addEventListener('touchend', (e) => handleTouch(e, 'end'), { passive: false });
        this.canvas.addEventListener('touchcancel', (e) => handleTouch(e, 'end'), { passive: false });
    }

    updateP1Stick(touchX, touchY) {
        let dx = touchX - this.p1.stickBase.x;
        let dy = touchY - this.p1.stickBase.y;
        const dist = Math.hypot(dx, dy);

        if (dist > this.p1.stickRadius) {
            const ratio = this.p1.stickRadius / dist;
            dx *= ratio;
            dy *= ratio;
        }
        this.p1.stickPos.x = dx;
        this.p1.stickPos.y = dy;
        this.p1.moveVector.x = dx / this.p1.stickRadius;
        this.p1.moveVector.y = dy / this.p1.stickRadius;
    }

    updateP2Input() {
        // activeTouchesの内容を集計してベクトル化
        let vx = 0;
        let vy = 0;
        let fire = false;

        Object.values(this.p2.activeTouches).forEach(btnId => {
            if (btnId === 'U') vy = -1;
            if (btnId === 'D') vy = 1;
            if (btnId === 'L') vx = -1;
            if (btnId === 'R') vx = 1;
            if (btnId === 'F') fire = true;
        });

        // 斜め移動の正規化
        if (vx !== 0 && vy !== 0) {
            const len = Math.hypot(vx, vy);
            vx /= len;
            vy /= len;
        }

        this.p2.moveVector.x = vx;
        this.p2.moveVector.y = vy;
        this.p2.btnActive = fire;
    }

    clearTap() {
        this.lastTap = null;
    }

    draw(ctx) {
        // --- Draw P1 UI ---
        // Stick Base
        ctx.beginPath();
        ctx.arc(this.p1.stickBase.x, this.p1.stickBase.y, this.p1.stickRadius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(100, 100, 255, 0.5)';
        ctx.stroke();

        // Stick Knob
        ctx.beginPath();
        ctx.arc(this.p1.stickBase.x + this.p1.stickPos.x, this.p1.stickBase.y + this.p1.stickPos.y, 30, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(100, 100, 255, 0.8)';
        ctx.fill();

        // Fire Button
        ctx.beginPath();
        ctx.arc(this.p1.btnPos.x, this.p1.btnPos.y, this.p1.btnRadius, 0, Math.PI * 2);
        ctx.fillStyle = this.p1.btnActive ? 'rgba(100, 100, 255, 0.8)' : 'rgba(100, 100, 255, 0.4)';
        ctx.fill();
        ctx.strokeStyle = 'white';
        ctx.stroke();
        ctx.fillStyle = 'white';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('P1 FIRE', this.p1.btnPos.x, this.p1.btnPos.y);

        // --- Draw P2 UI ---
        this.p2.buttons.forEach(btn => {
            ctx.fillStyle = 'rgba(100, 255, 100, 0.5)';
            // 押されているかチェック
            const isPressed = Object.values(this.p2.activeTouches).includes(btn.id);
            if (isPressed) ctx.fillStyle = 'rgba(100, 255, 100, 0.9)';
            
            ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
            
            ctx.fillStyle = '#000';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(btn.id, btn.x + btn.w/2, btn.y + btn.h/2);
        });
        
        ctx.fillStyle = '#FFF';
        ctx.fillText("P2", this.canvas.width - 50, 15);
    }
}

/**
 * Bulletクラス
 * ownerId: 1=P1, 2=P2
 */
class Bullet {
    constructor(x, y, vx, vy, ownerId) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.radius = 6;
        this.ownerId = ownerId;
        this.active = true;
    }

    update(width, height) {
        this.x += this.vx;
        this.y += this.vy;
        if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) {
            this.active = false;
        }
    }

    draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        // 色分け
        if (this.ownerId === 1) ctx.fillStyle = '#8888FF'; // P1: 薄青
        else if (this.ownerId === 2) ctx.fillStyle = '#88FF88'; // P2: 薄緑
        else ctx.fillStyle = '#FF00FF'; // Enemy
        ctx.fill();
    }
}

/**
 * Playerクラス
 */
class Player {
    constructor(id, x, y, color) {
        this.id = id; // 1 or 2
        this.startX = x;
        this.startY = y;
        this.x = x;
        this.y = y;
        this.color = color;
        this.radius = 15;
        this.speed = 5;
        
        this.maxHp = 100;
        this.hp = this.maxHp;
        this.lives = 3;
        
        this.isDead = false;
        this.invincibleUntil = 0;

        this.lastShotTime = 0;
        this.shotInterval = 150;
    }

    respawn() {
        this.x = this.startX;
        this.y = this.startY;
        this.hp = this.maxHp;
        this.isDead = false;
        this.invincibleUntil = Date.now() + 3000;
    }

    takeDamage(amount) {
        if (this.isDead || this.isInvincible()) return false;

        this.hp -= amount;
        if (this.hp <= 0) {
            this.hp = 0;
            this.lives--;
            this.isDead = true;
            return true; // 死亡通知
        }
        return false;
    }

    isInvincible() {
        return Date.now() < this.invincibleUntil;
    }

    update(inputData, width, height, bullets) {
        if (this.isDead) return;

        // 移動
        this.x += inputData.moveVector.x * this.speed;
        this.y += inputData.moveVector.y * this.speed;

        // 画面端の制限
        this.x = Math.max(this.radius, Math.min(width - this.radius, this.x));
        this.y = Math.max(this.radius, Math.min(height - this.radius, this.y));

        // 射撃
        if (inputData.btnActive) {
            const now = Date.now();
            if (now - this.lastShotTime > this.shotInterval) {
                this.shoot(bullets);
                this.lastShotTime = now;
            }
        }
    }

    shoot(bullets) {
        // P2は下向き、P1は上向きにする？ 対戦なので相手の方を向かせたいが
        // シンプルにするため、P1は上、P2は下、あるいは「移動方向」に撃つのが自然だが
        // トップダウンシューター（対面）想定で
        // P1(左側スタート) -> 右へ発射、 P2(右側スタート) -> 左へ発射
        // とりあえず今回は初期位置から「相手方向」に固定してみる、または
        // 上下に配置して撃ち合いにするのがスマホ横画面だと自然。
        // -> P1(左) vs P2(右) の配置にします。

        let vx = 0;
        let vy = 0;
        const speed = 12;

        if (this.id === 1) vx = speed;  // P1は右へ
        if (this.id === 2) vx = -speed; // P2は左へ

        bullets.push(new Bullet(this.x, this.y, vx, vy, this.id));
    }

    draw(ctx) {
        if (this.isDead) return;

        ctx.save();
        
        if (this.isInvincible()) {
            ctx.globalAlpha = 0.5;
            ctx.fillStyle = '#FFF';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('INVINCIBLE', this.x, this.y - 25);
        }

        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        
        // 向きがわかるように少し装飾
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        if (this.id === 1) ctx.fillRect(this.x, this.y - 5, 10, 10); // 右向きの目
        if (this.id === 2) ctx.fillRect(this.x - 10, this.y - 5, 10, 10); // 左向きの目

        ctx.restore();
    }
}

/**
 * Gameクラス
 */
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.input = new InputManager(this.canvas);
        
        this.resize();
        window.addEventListener('resize', () => this.resize());

        this.initGame();

        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    initGame() {
        // P1: 左側、青
        this.p1 = new Player(1, 100, this.canvas.height / 2, '#00CCFF');
        // P2: 右側、緑
        this.p2 = new Player(2, this.canvas.width - 100, this.canvas.height / 2, '#00FF66');
        
        this.bullets = [];
        this.winner = null; // 1 or 2
        this.isGameOver = false;

        // リスポーン管理用
        this.p1RespawnTimer = 0;
        this.p2RespawnTimer = 0;
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        if (this.input) this.input.updateLayout(this.canvas.width, this.canvas.height);
        
        // 画面リサイズ時に位置リセット等は行わない（戦闘中はずれる可能性があるため）
    }

    checkCollisions() {
        if (this.isGameOver) return;

        this.bullets.forEach(b => {
            if (!b.active) return;

            // 弾の持ち主以外のプレイヤーに当たり判定
            let target = null;
            if (b.ownerId === 1) target = this.p2;
            else if (b.ownerId === 2) target = this.p1;

            if (target && !target.isDead) {
                const dist = Math.hypot(b.x - target.x, b.y - target.y);
                if (dist < b.radius + target.radius) {
                    b.active = false;
                    // ダメージ処理
                    if (target.takeDamage(20)) {
                        // 死亡した場合
                        this.handlePlayerDeath(target);
                    }
                }
            }
        });
    }

    handlePlayerDeath(player) {
        if (player.lives < 0) {
            this.isGameOver = true;
            this.winner = (player.id === 1) ? 2 : 1; // 相手の勝ち
        } else {
            // リスポーンタイマー設定
            const respawnTime = Date.now() + 2000;
            if (player.id === 1) this.p1RespawnTimer = respawnTime;
            else this.p2RespawnTimer = respawnTime;
        }
    }

    update() {
        if (this.isGameOver) {
            this.checkRetry();
            this.input.clearTap();
            return;
        }

        // リスポーン処理 P1
        if (this.p1.isDead && this.p1.lives >= 0) {
            if (Date.now() > this.p1RespawnTimer) this.p1.respawn();
        }
        // リスポーン処理 P2
        if (this.p2.isDead && this.p2.lives >= 0) {
            if (Date.now() > this.p2RespawnTimer) this.p2.respawn();
        }

        // プレイヤー更新 (InputManagerから各プレイヤー用の入力を渡す)
        this.p1.update(this.input.p1, this.canvas.width, this.canvas.height, this.bullets);
        this.p2.update(this.input.p2, this.canvas.width, this.canvas.height, this.bullets);

        // 弾更新
        this.bullets.forEach(b => b.update(this.canvas.width, this.canvas.height));
        this.bullets = this.bullets.filter(b => b.active);

        this.checkCollisions();
        this.input.clearTap();
    }

    checkRetry() {
        const btnW = 160;
        const btnH = 50;
        const btnX = this.canvas.width / 2 - btnW / 2;
        const btnY = this.canvas.height / 2 + 80;

        if (this.input.lastTap) {
            const tap = this.input.lastTap;
            if (tap.x >= btnX && tap.x <= btnX + btnW &&
                tap.y >= btnY && tap.y <= btnY + btnH) {
                this.initGame();
            }
        }
    }

    drawUI() {
        const drawBar = (player, x, y, align) => {
            const width = 150;
            const height = 15;
            
            // Background
            this.ctx.fillStyle = '#555';
            this.ctx.fillRect(x, y, width, height);
            
            // Foreground
            const hpPercent = player.hp / player.maxHp;
            this.ctx.fillStyle = player.id === 1 ? '#00CCFF' : '#00FF66';
            this.ctx.fillRect(x, y, width * hpPercent, height);
            
            // Stroke
            this.ctx.strokeStyle = '#FFF';
            this.ctx.strokeRect(x, y, width, height);
            
            // Text
            this.ctx.fillStyle = '#FFF';
            this.ctx.font = '14px Arial';
            this.ctx.textAlign = 'left';
            this.ctx.fillText(`P${player.id} Lives: ${Math.max(0, player.lives)}`, x, y + 30);
        };

        drawBar(this.p1, 20, 20); // P1 Left Top
        drawBar(this.p2, this.canvas.width - 170, 20); // P2 Right Top
    }

    drawGameOver() {
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // WINNER テキスト
        this.ctx.fillStyle = this.winner === 1 ? '#00CCFF' : '#00FF66';
        this.ctx.font = 'bold 40px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(`PLAYER ${this.winner} WINS!`, this.canvas.width / 2, this.canvas.height / 2 - 20);

        // RETRY ボタン
        const btnW = 160;
        const btnH = 50;
        const btnX = this.canvas.width / 2 - btnW / 2;
        const btnY = this.canvas.height / 2 + 80;

        this.ctx.fillStyle = '#FFF';
        this.ctx.fillRect(btnX, btnY, btnW, btnH);

        this.ctx.fillStyle = '#000';
        this.ctx.font = 'bold 24px Arial';
        this.ctx.fillText('RETRY', this.canvas.width / 2, btnY + btnH / 2);
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        if (!this.isGameOver) {
            this.p1.draw(this.ctx);
            this.p2.draw(this.ctx);
            this.bullets.forEach(b => b.draw(this.ctx));
            this.drawUI();
            this.input.draw(this.ctx);
        } else {
            this.drawGameOver();
        }
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(this.loop);
    }
}

window.onload = () => {
    new Game();
};

</script>
</body>
</html>
