<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Crown Arena</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            color: white;
            font-family: 'Segoe UI', monospace;
            touch-action: none;
            user-select: none;
        }

        canvas {
            display: block;
        }

        /* --- UI Layers --- */
        .layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.9);
            z-index: 20;
            transition: opacity 0.3s;
        }

        .panel {
            background: #2a2a2a;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid #444;
            width: 320px;
            max-width: 90%;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }

        h1 { margin: 0 0 20px 0; color: #ffd700; font-size: 28px; text-shadow: 0 0 10px #ff8c00; }
        h2 { margin: 0 0 15px 0; font-size: 36px; font-weight: bold; }

        input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 6px;
            font-size: 16px;
            text-align: center;
        }

        button {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            color: white;
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.98); }

        .btn-host { background: #0078d7; }
        .btn-join { background: #107c10; }
        .btn-restart { background: #e6c200; color: black; }
        .btn-close { background: #d32f2f; }

        .win { color: #00ff00; }
        .lose { color: #ff0000; }
        .draw { color: #aaaaaa; }

        /* --- HUD --- */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* Timer */
        #timer-container {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 5px #000;
        }
        
        /* HP Bars */
        .player-info {
            position: absolute;
            top: 10px;
            font-size: 14px;
            text-shadow: 1px 1px 2px black;
        }
        .p1-info { left: 10px; }
        .p2-info { right: 10px; text-align: right; }

        .hp-bar-bg {
            width: 120px;
            height: 10px;
            background: #333;
            border: 1px solid #777;
            margin-top: 5px;
        }
        .hp-fill {
            height: 100%;
            background: #0f0;
            width: 100%;
            transition: width 0.2s, background-color 0.2s;
        }

        /* --- ULT UI --- */
        #ult-container {
            position: absolute;
            top: 60px;
            right: 10px;
            width: 60px;
            text-align: center;
            pointer-events: auto; /* ボタン押せるように */
        }
        .ult-gauge-bg {
            width: 100%;
            height: 8px;
            background: #333;
            border: 1px solid #aaa;
            margin-bottom: 5px;
        }
        .ult-fill {
            height: 100%;
            background: #d000ff;
            width: 0%;
            transition: width 0.2s;
        }
        #btn-ult {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #444;
            color: #888;
            font-weight: bold;
            font-size: 14px;
            border: 2px solid #666;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: default;
            transition: all 0.2s;
        }
        #btn-ult.ready {
            background: #9c27b0;
            color: white;
            border-color: #fff;
            box-shadow: 0 0 15px #d000ff;
            cursor: pointer;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        #room-id-display {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.5);
            font-size: 12px;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="layer-menu" class="layer">
        <div class="panel">
            <h1>Crown Arena</h1>
            <button class="btn-host" id="btn-create">Create Room (Host)</button>
            <div style="margin: 10px 0; color:#666;">- OR -</div>
            <input type="number" id="input-room" placeholder="4-Digit Room ID">
            <button class="btn-join" id="btn-join">Join Room</button>
            <div id="status-msg" style="margin-top:10px; color:#aaa; font-size:12px;">Ready</div>
        </div>
    </div>

    <div id="layer-wait" class="layer hidden">
        <div class="panel">
            <h1>Waiting for Player...</h1>
            <div>Room ID</div>
            <div id="display-room-code" style="font-size:32px; color:#ffeb3b; font-weight:bold; margin:10px 0;">----</div>
            <div style="font-size: 12px; color: #aaa;">Share this ID</div>
        </div>
    </div>

    <div id="layer-result" class="layer hidden">
        <div class="panel">
            <h2 id="result-title">RESULT</h2>
            <div id="result-msg" style="margin-bottom:20px;"></div>
            
            <div id="host-controls" class="hidden">
                <button class="btn-restart" id="btn-restart">Play Again</button>
                <button class="btn-close" id="btn-close">Disband Room</button>
            </div>
            
            <div id="guest-controls" class="hidden">
                <div style="color:#aaa; margin-bottom:10px;">Waiting for Host...</div>
                <button class="btn-close" id="btn-leave">Leave Room</button>
            </div>
        </div>
    </div>

    <div id="hud" class="hidden">
        <div id="timer-container">60</div>

        <div class="player-info p1-info">
            P1 (Blue)
            <div class="hp-bar-bg"><div id="bar-hp-p1" class="hp-fill"></div></div>
        </div>
        
        <div class="player-info p2-info">
            P2 (Green)
            <div class="hp-bar-bg"><div id="bar-hp-p2" class="hp-fill"></div></div>
        </div>

        <div id="ult-container">
            <div class="ult-gauge-bg"><div id="bar-ult" class="ult-fill"></div></div>
            <div id="btn-ult">ULT</div>
        </div>

        <div id="room-id-display">Room: ----</div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script type="module">
    // ---------------------------------------------------------
    // 1. Firebase Config & Imports
    // ---------------------------------------------------------
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { 
        getFirestore, doc, setDoc, updateDoc, onSnapshot, getDoc, deleteDoc, increment 
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    const firebaseConfig = {
        apiKey: "AIzaSyA8B-JtwDskK3omhjUCbjERHBZ6UDdm854",
        authDomain: "crownarena-1a321.firebaseapp.com",
        projectId: "crownarena-1a321",
        storageBucket: "crownarena-1a321.firebasestorage.app",
        messagingSenderId: "103440875843",
        appId: "1:103440875843:web:d34b314c4df7e0d491aff6",
        measurementId: "G-N9KDL9B9Y5"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // ---------------------------------------------------------
    // 2. Constants & Globals
    // ---------------------------------------------------------
    const CANVAS = document.getElementById('gameCanvas');
    const CTX = CANVAS.getContext('2d');
    
    // Game Config
    const PLAYER_RADIUS = 20;
    const BULLET_RADIUS = 6;
    const ULT_RADIUS = 20;
    const MOVE_SPEED = 5;
    const BULLET_SPEED = 12;
    const FIRE_RATE = 200; 
    const SYNC_INTERVAL = 50; 
    
    const GAME_DURATION = 60; 
    const ULT_MAX = 100;
    const ULT_CHARGE_PASSIVE = 5; // 毎秒
    const ULT_CHARGE_HIT = 10;    // 被弾時

    // ---------------------------------------------------------
    // 3. Game Logic Class
    // ---------------------------------------------------------
    class Game {
        constructor() {
            this.roomId = null;
            this.isHost = false; 
            this.myId = null; // 'p1' or 'p2'
            
            // ゲーム状態
            this.state = {
                players: {
                    p1: { x: 100, y: 100, hp: 100, isShooting: false, active: false, ult: 0, slowUntil: 0 },
                    p2: { x: 300, y: 100, hp: 100, isShooting: false, active: false, ult: 0, slowUntil: 0 }
                },
                status: "waiting", // waiting, playing, finished
                remainingTime: GAME_DURATION,
                bulletSeq: 0,
                ultSeq: 0
            };

            this.localBullets = []; // Client Prediction用

            // Input
            this.input = { x: 0, y: 0, fire: false };
            this.touchId = null;
            this.stickBase = { x: 100, y: 300 };
            
            // Timers
            this.lastSyncTime = 0;
            this.lastTimeTick = 0;
            this.lastFrameTime = Date.now();
            this.unsubscribe = null;
            this.isRoomReady = false;

            this.resize();
            window.addEventListener('resize', () => this.resize());
            this.setupInputs();
            
            // UI References
            this.layers = {
                menu: document.getElementById('layer-menu'),
                wait: document.getElementById('layer-wait'),
                result: document.getElementById('layer-result')
            };
            this.hud = document.getElementById('hud');
            
            this.bindButtons();

            // Loop
            requestAnimationFrame((t) => this.loop(t));
        }

        resize() {
            CANVAS.width = window.innerWidth;
            CANVAS.height = window.innerHeight;
            this.stickBase = { x: 120, y: CANVAS.height - 120 };
        }

        // --- Network Actions ---

        async createRoom() {
            this.roomId = Math.floor(1000 + Math.random() * 9000).toString();
            this.isHost = true;
            this.myId = 'p1';
            
            // 初期化
            this.state.players.p1.active = true;
            this.state.players.p1.x = 100;
            this.state.players.p1.hp = 100;
            this.state.players.p1.ult = 0;
            this.state.players.p1.slowUntil = 0;

            const initialData = {
                players: {
                    p1: this.state.players.p1,
                    p2: { x: 300, y: 100, hp: 100, isShooting: false, active: false, ult: 0, slowUntil: 0 }
                },
                status: "waiting",
                remainingTime: GAME_DURATION,
                winner: null,
                bulletSeq: 0,
                ultSeq: 0,
                lastShooter: null
            };

            try {
                await setDoc(doc(db, "rooms", this.roomId), initialData);
                this.isRoomReady = true;
                this.switchLayer('wait');
                document.getElementById('display-room-code').innerText = this.roomId;
                document.getElementById('room-id-display').innerText = "Room: " + this.roomId;
                this.subscribeToRoom();
            } catch (e) {
                alert("Error: " + e.message);
            }
        }

        async joinRoom(id) {
            const docRef = doc(db, "rooms", id);
            try {
                const snap = await getDoc(docRef);
                if (!snap.exists()) { alert("Room not found!"); return; }

                this.roomId = id;
                this.isHost = false;
                this.myId = 'p2';

                this.state.players.p2.active = true;
                this.state.players.p2.x = CANVAS.width - 100;
                this.state.players.p2.hp = 100;
                this.state.players.p2.ult = 0;

                await updateDoc(docRef, {
                    "players.p2.active": true,
                    "players.p2.x": this.state.players.p2.x,
                    "status": "playing"
                });

                document.getElementById('room-id-display').innerText = "Room: " + this.roomId;
                this.isRoomReady = true;
                this.subscribeToRoom();

            } catch (e) {
                alert("Error joining: " + e.message);
            }
        }

        subscribeToRoom() {
            if (this.unsubscribe) this.unsubscribe();
            
            this.unsubscribe = onSnapshot(doc(db, "rooms", this.roomId), (docSnap) => {
                if (!docSnap.exists()) {
                    if (this.isRoomReady) { alert("Room disbanded."); location.reload(); }
                    return;
                }
                const data = docSnap.data();
                
                // 1. ステータス同期
                if (data.status === "playing") {
                    this.switchLayer(null); 
                    this.state.status = "playing";
                    this.hud.classList.remove('hidden');
                } else if (data.status === "finished") {
                    this.state.status = "finished";
                    this.hud.classList.add('hidden');
                    this.showResult(data.winner);
                }

                // 2. タイマー同期
                if (data.remainingTime !== undefined) {
                    this.state.remainingTime = data.remainingTime;
                }

                // 3. 弾丸イベント
                if (data.bulletSeq > this.state.bulletSeq) {
                    if (data.lastShooter !== this.myId) {
                        this.spawnBulletFromSync(data.lastShooter, false);
                    }
                    this.state.bulletSeq = data.bulletSeq;
                }
                if (data.ultSeq > this.state.ultSeq) {
                    if (data.lastShooter !== this.myId) {
                        this.spawnBulletFromSync(data.lastShooter, true);
                    }
                    this.state.ultSeq = data.ultSeq;
                }

                // 4. プレイヤー情報同期
                if (this.isHost) {
                    // Host: P2の入力系のみ受信
                    if (data.players.p2) {
                        const p2 = this.state.players.p2;
                        p2.x = data.players.p2.x;
                        p2.y = data.players.p2.y;
                        p2.isShooting = data.players.p2.isShooting;
                        p2.active = data.players.p2.active;
                    }
                } else {
                    // Guest: P1全情報 + 自分のStatus(HP, Ult, Slow)を受信
                    if (data.players.p1) {
                        Object.assign(this.state.players.p1, data.players.p1);
                    }
                    if (data.players.p2) {
                        const p2 = this.state.players.p2;
                        p2.hp = data.players.p2.hp;
                        p2.ult = data.players.p2.ult;
                        p2.slowUntil = data.players.p2.slowUntil;
                        p2.active = data.players.p2.active;
                    }
                }
                
                this.updateUI();
            });
        }

        async syncToFirestore() {
            if (!this.roomId || this.state.status === "finished") return;
            const ref = doc(db, "rooms", this.roomId);
            const me = this.state.players[this.myId];

            try {
                if (this.isHost) {
                    // Host: 全データの権限を持つ
                    await updateDoc(ref, {
                        "remainingTime": Math.ceil(this.state.remainingTime),
                        
                        "players.p1.x": me.x,
                        "players.p1.y": me.y,
                        "players.p1.isShooting": me.isShooting,
                        "players.p1.hp": this.state.players.p1.hp,
                        "players.p1.ult": Math.floor(this.state.players.p1.ult),
                        "players.p1.slowUntil": this.state.players.p1.slowUntil,

                        "players.p2.hp": this.state.players.p2.hp,
                        "players.p2.ult": Math.floor(this.state.players.p2.ult),
                        "players.p2.slowUntil": this.state.players.p2.slowUntil
                    });
                } else {
                    // Guest: 操作のみ送信
                    await updateDoc(ref, {
                        "players.p2.x": me.x,
                        "players.p2.y": me.y,
                        "players.p2.isShooting": me.isShooting
                    });
                }
            } catch (e) { /* ignore lag */ }
        }

        // --- Logic ---

        triggerFire() {
            const now = Date.now();
            const me = this.state.players[this.myId];
            if (now - (me.lastFire || 0) < FIRE_RATE) return;
            me.lastFire = now;

            this.spawnBulletLocal(this.myId, false);
            this.sendFireEvent(false);
        }

        triggerUlt() {
            const me = this.state.players[this.myId];
            if (me.ult < ULT_MAX) return;

            me.ult = 0;
            this.spawnBulletLocal(this.myId, true);
            this.sendFireEvent(true);
        }

        async sendFireEvent(isUlt) {
            const ref = doc(db, "rooms", this.roomId);
            try {
                if (isUlt) {
                    await updateDoc(ref, { ultSeq: increment(1), lastShooter: this.myId });
                } else {
                    await updateDoc(ref, { bulletSeq: increment(1), lastShooter: this.myId });
                }
            } catch(e) {}
        }

        spawnBulletFromSync(shooterId, isUlt) {
            this.spawnBulletLocal(shooterId, isUlt);
        }

        spawnBulletLocal(ownerId, isUlt) {
            const p = this.state.players[ownerId];
            if (!p || !p.active) return;

            let vx = (ownerId === 'p1') ? BULLET_SPEED : -BULLET_SPEED;
            this.localBullets.push({
                x: p.x, y: p.y, vx: vx, vy: 0, 
                owner: ownerId, isUlt: isUlt, 
                r: isUlt ? ULT_RADIUS : BULLET_RADIUS
            });
        }

        // --- Loop ---

        update(dt) {
            const now = Date.now();
            const deltaTimeSec = (now - this.lastFrameTime) / 1000;
            this.lastFrameTime = now;

            if (this.state.status === "playing") {
                // 1. Host Logic
                if (this.isHost) {
                    // Timer
                    if (now - this.lastTimeTick > 1000) {
                        this.state.remainingTime -= 1;
                        this.lastTimeTick = now;
                        if (this.state.remainingTime <= 0) {
                            this.checkTimeOver();
                        }
                    }
                    // Passive ULT Charge (Hostが計算してSyncで送る)
                    ['p1', 'p2'].forEach(pid => {
                        const p = this.state.players[pid];
                        if (p.active && p.ult < ULT_MAX) {
                            p.ult += ULT_CHARGE_PASSIVE * deltaTimeSec;
                            if (p.ult > ULT_MAX) p.ult = ULT_MAX;
                        }
                    });
                }

                // 2. Movement
                const me = this.state.players[this.myId];
                if (me) {
                    let speed = MOVE_SPEED;
                    if (now < me.slowUntil) speed *= 0.5;

                    me.x += this.input.x * speed;
                    me.y += this.input.y * speed;
                    me.x = Math.max(20, Math.min(CANVAS.width - 20, me.x));
                    me.y = Math.max(20, Math.min(CANVAS.height - 20, me.y));

                    if (this.input.fire) this.triggerFire();
                }
            }

            this.updateBullets(now);

            if (now - this.lastSyncTime > SYNC_INTERVAL) {
                this.syncToFirestore();
                this.lastSyncTime = now;
            }
        }

        updateBullets(now) {
            // 移動
            this.localBullets.forEach(b => {
                b.x += b.vx;
                b.y += b.vy;
            });

            // 削除
            this.localBullets = this.localBullets.filter(b => 
                b.x > 0 && b.x < CANVAS.width && b.y > 0 && b.y < CANVAS.height
            );

            // 当たり判定 (貫通防止のためGuestも判定して消す)
            this.localBullets = this.localBullets.filter(b => {
                let hit = false;
                const targetId = b.owner === 'p1' ? 'p2' : 'p1';
                const target = this.state.players[targetId];

                if (target.active && target.hp > 0) {
                    const dx = b.x - target.x;
                    const dy = b.y - target.y;
                    
                    if (Math.hypot(dx, dy) < PLAYER_RADIUS + b.r) {
                        hit = true; 
                        
                        // ★ HP計算はHostのみ
                        if (this.isHost) {
                            const dmg = b.isUlt ? 20 : 10;
                            target.hp -= dmg;
                            
                            // ULTチャージ (被弾)
                            target.ult = Math.min(ULT_MAX, target.ult + ULT_CHARGE_HIT);

                            if (b.isUlt) target.slowUntil = now + 3000;

                            if (target.hp <= 0) {
                                target.hp = 0;
                                this.endGame(b.owner);
                            }
                        }
                    }
                }
                return !hit; 
            });
        }

        checkTimeOver() {
            const p1 = this.state.players.p1.hp;
            const p2 = this.state.players.p2.hp;
            let winner = null;
            if (p1 > p2) winner = 'p1';
            else if (p2 > p1) winner = 'p2';
            else winner = 'draw';
            this.endGame(winner);
        }

        async endGame(winnerId) {
            if (!this.isHost || this.state.status === "finished") return;
            this.state.status = "finished";
            
            await updateDoc(doc(db, "rooms", this.roomId), {
                "status": "finished",
                "winner": winnerId,
                "remainingTime": 0,
                "players.p1.hp": this.state.players.p1.hp,
                "players.p2.hp": this.state.players.p2.hp
            });
        }

        // --- UI ---

        switchLayer(name) {
            for (let key in this.layers) {
                if (key === name) this.layers[key].classList.remove('hidden');
                else this.layers[key].classList.add('hidden');
            }
        }

        updateUI() {
            // Timer
            const timerEl = document.getElementById('timer-container');
            if (timerEl) {
                timerEl.innerText = Math.max(0, Math.floor(this.state.remainingTime));
            }

            // HP Bars (Width Only)
            const p1 = this.state.players.p1;
            const p2 = this.state.players.p2;
            
            const barP1 = document.getElementById('bar-hp-p1');
            if (barP1) {
                barP1.style.width = Math.max(0, p1.hp) + "%";
                barP1.style.backgroundColor = p1.hp > 30 ? '#0f0' : '#f00';
            }

            const barP2 = document.getElementById('bar-hp-p2');
            if (barP2) {
                barP2.style.width = Math.max(0, p2.hp) + "%";
                barP2.style.backgroundColor = p2.hp > 30 ? '#0f0' : '#f00';
            }

            // ULT (自分の分だけ)
            const myUlt = this.state.players[this.myId]?.ult || 0;
            const barUlt = document.getElementById('bar-ult');
            if (barUlt) {
                barUlt.style.width = Math.min(100, Math.max(0, myUlt)) + "%";
            }
            
            const btnUlt = document.getElementById('btn-ult');
            if (btnUlt) {
                if (myUlt >= ULT_MAX) btnUlt.classList.add('ready');
                else btnUlt.classList.remove('ready');
            }
        }

        showResult(winnerId) {
            this.switchLayer('result');
            const title = document.getElementById('result-title');
            const msg = document.getElementById('result-msg');
            
            if (winnerId === 'draw') {
                title.innerText = "DRAW";
                title.className = "draw";
                msg.innerText = "Time Over";
            } else {
                const amIWinner = (winnerId === this.myId);
                if (amIWinner) {
                    title.innerText = "YOU WIN!";
                    title.className = "win";
                    msg.innerText = "Congratulations!";
                } else {
                    title.innerText = "YOU LOSE";
                    title.className = "lose";
                    msg.innerText = "Try again next time.";
                }
            }

            if (this.isHost) {
                document.getElementById('host-controls').classList.remove('hidden');
                document.getElementById('guest-controls').classList.add('hidden');
            } else {
                document.getElementById('host-controls').classList.add('hidden');
                document.getElementById('guest-controls').classList.remove('hidden');
            }
        }

        async restartGame() {
            if (!this.isHost) return;
            
            // リセット
            this.state.players.p1.hp = 100;
            this.state.players.p1.x = 100;
            this.state.players.p1.ult = 0;
            this.state.players.p1.slowUntil = 0;
            
            this.state.players.p2.hp = 100;
            this.state.players.p2.x = CANVAS.width - 100;
            this.state.players.p2.ult = 0;
            this.state.players.p2.slowUntil = 0;
            
            this.state.remainingTime = GAME_DURATION;
            this.state.status = "playing";
            this.localBullets = []; 

            await updateDoc(doc(db, "rooms", this.roomId), {
                "players.p1.hp": 100,
                "players.p1.x": 100,
                "players.p1.ult": 0,
                "players.p2.hp": 100,
                "players.p2.x": CANVAS.width - 100,
                "players.p2.ult": 0,
                "status": "playing",
                "remainingTime": GAME_DURATION,
                "winner": null
            });
        }

        async disbandRoom() {
            if (!this.isHost) return;
            try {
                await deleteDoc(doc(db, "rooms", this.roomId));
                location.reload();
            } catch (e) { console.error(e); }
        }

        draw() {
            CTX.fillStyle = '#222';
            CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

            // Players
            ['p1', 'p2'].forEach(pid => {
                const p = this.state.players[pid];
                if (!p.active) return;
                
                CTX.beginPath();
                CTX.arc(p.x, p.y, PLAYER_RADIUS, 0, Math.PI*2);
                CTX.fillStyle = pid === 'p1' ? '#00ccff' : '#00ff00';
                CTX.fill();
                
                // Slow Effect
                if (Date.now() < p.slowUntil) {
                    CTX.strokeStyle = '#00ffff';
                    CTX.lineWidth = 3;
                    CTX.stroke();
                } else {
                    CTX.strokeStyle = 'white';
                    CTX.lineWidth = 2;
                    CTX.stroke();
                }
            });

            // Bullets
            this.localBullets.forEach(b => {
                CTX.beginPath();
                CTX.arc(b.x, b.y, b.r, 0, Math.PI*2);
                if (b.isUlt) {
                    CTX.fillStyle = '#d000ff';
                    CTX.shadowBlur = 10;
                    CTX.shadowColor = '#d000ff';
                } else {
                    CTX.fillStyle = '#ffeb3b';
                    CTX.shadowBlur = 0;
                }
                CTX.fill();
                CTX.shadowBlur = 0;
            });

            // Stick
            CTX.beginPath();
            CTX.arc(this.stickBase.x, this.stickBase.y, 50, 0, Math.PI*2);
            CTX.strokeStyle = 'rgba(255,255,255,0.3)';
            CTX.lineWidth = 2;
            CTX.stroke();
            CTX.beginPath();
            CTX.arc(this.stickBase.x + this.input.x*50, this.stickBase.y + this.input.y*50, 25, 0, Math.PI*2);
            CTX.fillStyle = 'rgba(255,255,255,0.5)';
            CTX.fill();

            // Fire Button
            const fireX = CANVAS.width - 100;
            const fireY = CANVAS.height - 120;
            CTX.beginPath();
            CTX.arc(fireX, fireY, 40, 0, Math.PI*2);
            CTX.fillStyle = this.input.fire ? 'rgba(255,50,50,0.6)' : 'rgba(255,50,50,0.3)';
            CTX.fill();
            CTX.strokeStyle = 'white';
            CTX.lineWidth = 2;
            CTX.stroke();
            CTX.fillStyle = 'white';
            CTX.font = '14px Arial';
            CTX.textAlign = 'center';
            CTX.fillText("FIRE", fireX, fireY + 5);
        }

        loop(timestamp) {
            this.update();
            this.draw();
            requestAnimationFrame((t) => this.loop(t));
        }

        // --- Inputs ---
        bindButtons() {
            document.getElementById('btn-create').onclick = () => this.createRoom();
            document.getElementById('btn-join').onclick = () => {
                const id = document.getElementById('input-room').value;
                if(id.length === 4) this.joinRoom(id);
                else alert("Enter 4 digits");
            };
            document.getElementById('btn-restart').onclick = () => this.restartGame();
            document.getElementById('btn-close').onclick = () => this.disbandRoom();
            document.getElementById('btn-leave').onclick = () => location.reload();
            document.getElementById('btn-ult').onclick = (e) => {
                e.stopPropagation();
                this.triggerUlt();
            };
        }

        setupInputs() {
            const handleTouch = (e) => {
                e.preventDefault();
                const touches = e.changedTouches;
                for (let i = 0; i < touches.length; i++) {
                    const t = touches[i];
                    
                    if (t.clientX < CANVAS.width / 2) {
                        this.touchId = t.identifier;
                        const dx = t.clientX - this.stickBase.x;
                        const dy = t.clientY - this.stickBase.y;
                        const dist = Math.hypot(dx, dy);
                        const max = 50;
                        if (dist > max) { this.input.x = (dx / dist); this.input.y = (dy / dist); }
                        else { this.input.x = dx / max; this.input.y = dy / max; }
                    } else {
                        const dist = Math.hypot(t.clientX - (CANVAS.width - 100), t.clientY - (CANVAS.height - 120));
                        if (dist < 60) this.input.fire = true;
                    }
                }
            };
            const handleEnd = (e) => {
                e.preventDefault();
                const touches = e.changedTouches;
                for (let i = 0; i < touches.length; i++) {
                    const t = touches[i];
                    if (t.identifier === this.touchId) { this.input.x = 0; this.input.y = 0; this.touchId = null; }
                    if (t.clientX > CANVAS.width / 2) this.input.fire = false;
                }
            };
            CANVAS.addEventListener('touchstart', handleTouch, {passive: false});
            CANVAS.addEventListener('touchmove', handleTouch, {passive: false});
            CANVAS.addEventListener('touchend', handleEnd, {passive: false});
        }
    }

    window.onload = () => new Game();
</script>
</body>
</html>
