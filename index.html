<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Canvas Mobile Shooter</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* スクロール禁止 */
            background-color: #222;
            touch-action: none; /* スマホでのピンチズーム等を無効化 */
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * ユーティリティ: ベクトル計算用
 */
class Vec2 {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

/**
 * InputManagerクラス
 * タッチ操作（仮想スティックとボタン）を管理
 */
class InputManager {
    constructor(canvas) {
        this.canvas = canvas;
        
        // 仮想スティック（左側）
        this.stickBase = new Vec2(150, canvas.height - 150); // 基準位置
        this.stickPos = new Vec2(0, 0); // 入力位置（相対）
        this.stickRadius = 60; // 土台の半径
        this.knobRadius = 30;  // つまみの半径
        this.stickActive = false;
        this.stickTouchId = null;
        this.moveVector = new Vec2(0, 0); // 正規化された移動ベクトル

        // 射撃ボタン（右側）
        this.btnPos = new Vec2(canvas.width - 150, canvas.height - 150);
        this.btnRadius = 50;
        this.btnActive = false;
        this.btnTouchId = null;

        // イベントリスナー設定
        this.setupEvents();
    }

    updateLayout(width, height) {
        // 画面サイズが変わったらUI位置を再計算
        this.stickBase = new Vec2(120, height - 120);
        this.btnPos = new Vec2(width - 120, height - 120);
    }

    setupEvents() {
        // タッチ開始
        this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                const x = t.clientX;
                const y = t.clientY;

                // 左画面エリア: スティック操作
                if (x < this.canvas.width / 2 && !this.stickActive) {
                    this.stickActive = true;
                    this.stickTouchId = t.identifier;
                    // タッチした場所を基準にする場合はここを調整（現在は固定位置からドラッグ）
                    this.updateStick(x, y);
                }
                // 右画面エリア: 射撃ボタン
                else if (x >= this.canvas.width / 2) {
                    const dist = Math.hypot(x - this.btnPos.x, y - this.btnPos.y);
                    // ボタン付近をタップしたか、あるいは右側ならどこでもOKにするか（ここは右側広めに判定）
                    if (dist < 100) { 
                        this.btnActive = true;
                        this.btnTouchId = t.identifier;
                    }
                }
            }
        }, { passive: false });

        // タッチ移動
        this.canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if (t.identifier === this.stickTouchId) {
                    this.updateStick(t.clientX, t.clientY);
                }
            }
        }, { passive: false });

        // タッチ終了
        const endHandler = (e) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if (t.identifier === this.stickTouchId) {
                    this.stickActive = false;
                    this.stickTouchId = null;
                    this.stickPos.x = 0;
                    this.stickPos.y = 0;
                    this.moveVector.x = 0;
                    this.moveVector.y = 0;
                }
                if (t.identifier === this.btnTouchId) {
                    this.btnActive = false;
                    this.btnTouchId = null;
                }
            }
        };
        this.canvas.addEventListener('touchend', endHandler);
        this.canvas.addEventListener('touchcancel', endHandler);
    }

    updateStick(touchX, touchY) {
        let dx = touchX - this.stickBase.x;
        let dy = touchY - this.stickBase.y;
        const dist = Math.hypot(dx, dy);

        // 半径内に収める
        if (dist > this.stickRadius) {
            const ratio = this.stickRadius / dist;
            dx *= ratio;
            dy *= ratio;
        }

        this.stickPos.x = dx;
        this.stickPos.y = dy;

        // 移動ベクトルの計算 (-1.0 ~ 1.0)
        this.moveVector.x = dx / this.stickRadius;
        this.moveVector.y = dy / this.stickRadius;
    }

    // UI描画
    draw(ctx) {
        // スティックベース
        ctx.beginPath();
        ctx.arc(this.stickBase.x, this.stickBase.y, this.stickRadius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.stroke();

        // スティックノブ
        ctx.beginPath();
        ctx.arc(this.stickBase.x + this.stickPos.x, this.stickBase.y + this.stickPos.y, this.knobRadius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.fill();

        // 射撃ボタン
        ctx.beginPath();
        ctx.arc(this.btnPos.x, this.btnPos.y, this.btnRadius, 0, Math.PI * 2);
        ctx.fillStyle = this.btnActive ? 'rgba(255, 50, 50, 0.8)' : 'rgba(255, 50, 50, 0.4)';
        ctx.fill();
        ctx.strokeStyle = 'white';
        ctx.stroke();
        
        ctx.fillStyle = 'white';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('FIRE', this.btnPos.x, this.btnPos.y);
    }
}

/**
 * Bulletクラス
 * プレイヤーと敵の弾を兼ねる
 */
class Bullet {
    constructor(x, y, vx, vy, isPlayerBullet) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.radius = 5;
        this.isPlayerBullet = isPlayerBullet;
        this.active = true;
    }

    update(width, height) {
        this.x += this.vx;
        this.y += this.vy;

        // 画面外に出たら消去
        if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) {
            this.active = false;
        }
    }

    draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.isPlayerBullet ? '#FFFF00' : '#FF00FF'; // プレイヤー:黄, 敵:紫
        ctx.fill();
    }
}

/**
 * Playerクラス
 */
class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 15;
        this.speed = 5;
        this.hp = 100;
        this.maxHp = 100;
        this.lastShotTime = 0;
        this.shotInterval = 150; // 連射間隔(ms)
    }

    update(input, width, height, bullets) {
        // 移動
        this.x += input.moveVector.x * this.speed;
        this.y += input.moveVector.y * this.speed;

        // 画面端の制限
        this.x = Math.max(this.radius, Math.min(width - this.radius, this.x));
        this.y = Math.max(this.radius, Math.min(height - this.radius, this.y));

        // 射撃
        if (input.btnActive) {
            const now = Date.now();
            if (now - this.lastShotTime > this.shotInterval) {
                this.shoot(bullets);
                this.lastShotTime = now;
            }
        }
    }

    shoot(bullets) {
        // 上に向かって発射
        bullets.push(new Bullet(this.x, this.y - 20, 0, -10, true));
    }

    draw(ctx) {
        // 本体
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - this.radius);
        ctx.lineTo(this.x + this.radius, this.y + this.radius);
        ctx.lineTo(this.x - this.radius, this.y + this.radius);
        ctx.closePath();
        ctx.fillStyle = '#00CCFF';
        ctx.fill();
    }
}

/**
 * Enemyクラス（ダメージテスト用）
 */
class Enemy {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 15;
        this.speed = 2;
        this.active = true;
        this.lastShotTime = Date.now();
        this.shotInterval = 2000;
    }

    update(player, bullets) {
        // プレイヤーに向かって移動
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.hypot(dx, dy);
        
        if (dist > 0) {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
        }

        // 定期的に弾を撃つ
        const now = Date.now();
        if (now - this.lastShotTime > this.shotInterval) {
            // プレイヤーへのベクトル
            const bulletSpeed = 6;
            bullets.push(new Bullet(this.x, this.y, (dx / dist) * bulletSpeed, (dy / dist) * bulletSpeed, false));
            this.lastShotTime = now;
        }
    }

    draw(ctx) {
        ctx.beginPath();
        ctx.rect(this.x - 15, this.y - 15, 30, 30);
        ctx.fillStyle = '#FF4444';
        ctx.fill();
    }
}

/**
 * Gameクラス
 * ゲームループと全体管理
 */
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();

        this.input = new InputManager(this.canvas);
        this.player = new Player(this.canvas.width / 2, this.canvas.height / 2);
        this.bullets = [];
        this.enemies = [];
        this.isGameOver = false;

        // リサイズ対応
        window.addEventListener('resize', () => this.resize());

        // 敵スポーンタイマー
        this.lastSpawnTime = 0;

        // ループ開始
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        // UI位置の再計算
        if (this.input) this.input.updateLayout(this.canvas.width, this.canvas.height);
    }

    // 敵の生成
    spawnEnemy() {
        const now = Date.now();
        if (now - this.lastSpawnTime > 1500) { // 1.5秒ごとに生成
            const x = Math.random() * this.canvas.width;
            const y = -50; // 画面上から出現
            this.enemies.push(new Enemy(x, y));
            this.lastSpawnTime = now;
        }
    }

    // 当たり判定
    checkCollisions() {
        // 弾とプレイヤー/敵の判定
        this.bullets.forEach(b => {
            if (!b.active) return;

            if (b.isPlayerBullet) {
                // 対 敵
                this.enemies.forEach(e => {
                    if (!e.active) return;
                    const dist = Math.hypot(b.x - e.x, b.y - e.y);
                    if (dist < b.radius + e.radius + 10) { // 少し甘めの判定
                        e.active = false; // 敵死亡
                        b.active = false;
                    }
                });
            } else {
                // 対 プレイヤー
                const dist = Math.hypot(b.x - this.player.x, b.y - this.player.y);
                if (dist < b.radius + this.player.radius) {
                    this.player.hp -= 20; // 20ダメージ
                    b.active = false;
                    if (this.player.hp < 0) this.player.hp = 0;
                }
            }
        });
    }

    drawUI() {
        // HPバー背景
        this.ctx.fillStyle = '#555';
        this.ctx.fillRect(20, 20, 200, 20);
        
        // HPバー現在値
        const hpPercent = this.player.hp / this.player.maxHp;
        this.ctx.fillStyle = hpPercent > 0.3 ? '#00FF00' : '#FF0000';
        this.ctx.fillRect(20, 20, 200 * hpPercent, 20);
        
        // HP枠線
        this.ctx.strokeStyle = '#FFF';
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(20, 20, 200, 20);

        // テキスト
        this.ctx.fillStyle = '#FFF';
        this.ctx.font = '14px Arial';
        this.ctx.textAlign = 'left';
        this.ctx.fillText(`HP: ${this.player.hp}`, 230, 35);
    }

    drawGameOver() {
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.fillStyle = '#FFF';
        this.ctx.font = '40px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2);
        
        this.ctx.font = '20px Arial';
        this.ctx.fillText('Reload to Restart', this.canvas.width / 2, this.canvas.height / 2 + 50);
    }

    update() {
        if (this.isGameOver) return;

        // ゲームオーバー判定
        if (this.player.hp <= 0) {
            this.isGameOver = true;
        }

        this.spawnEnemy();
        this.player.update(this.input, this.canvas.width, this.canvas.height, this.bullets);

        // 弾の更新と削除
        this.bullets.forEach(b => b.update(this.canvas.width, this.canvas.height));
        this.bullets = this.bullets.filter(b => b.active);

        // 敵の更新と削除
        this.enemies.forEach(e => e.update(this.player, this.bullets));
        this.enemies = this.enemies.filter(e => e.active);

        this.checkCollisions();
    }

    draw() {
        // 画面クリア
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        if (!this.isGameOver) {
            this.player.draw(this.ctx);
            this.enemies.forEach(e => e.draw(this.ctx));
            this.bullets.forEach(b => b.draw(this.ctx));
            this.drawUI(); // HPバーなど
            this.input.draw(this.ctx); // コントローラー
        } else {
            this.drawGameOver();
        }
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(this.loop);
    }
}

// ゲーム起動
window.onload = () => {
    new Game();
};

</script>
</body>
</html>